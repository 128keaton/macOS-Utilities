// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.16.9 clang-1200.0.22.5)
// swift-module-flags: -target x86_64-apple-macos10.12 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AudioKit
import AVFoundation
import Accelerate
@_exported import AudioKit
import AudioToolbox
import CoreAudio
import CoreAudioKit
import CoreMIDI
import Dispatch
import Foundation
import Swift
import os
@objc open class AKReverb2 : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var gain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var minDelayTime: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var maxDelayTime: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayTimeAt0Hz: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayTimeAtNyquist: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var randomizeReflections: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, dryWetMix: AudioToolbox.AUValue = 0.5, gain: AudioToolbox.AUValue = 0, minDelayTime: AudioToolbox.AUValue = 0.008, maxDelayTime: AudioToolbox.AUValue = 0.050, decayTimeAt0Hz: AudioToolbox.AUValue = 1.0, decayTimeAtNyquist: AudioToolbox.AUValue = 0.5, randomizeReflections: AudioToolbox.AUValue = 1)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKCompressor : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var threshold: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var headRoom: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var compressionAmount: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var inputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var outputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var masterGain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, threshold: AudioToolbox.AUValue = -20, headRoom: AudioToolbox.AUValue = 5, attackDuration: AudioToolbox.AUValue = 0.001, releaseDuration: AudioToolbox.AUValue = 0.05, masterGain: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKCompressor
}
@objc @_inheritsConvenienceInitializers open class AKAudioUnitBase : AudioToolbox.AUAudioUnit {
  @objc override dynamic public func allocateRenderResources() throws
  @objc override dynamic public func deallocateRenderResources()
  @objc override dynamic public func reset()
  @objc override dynamic public var inputBusses: AudioToolbox.AUAudioUnitBusArray {
    @objc get
  }
  @objc override dynamic public var outputBusses: AudioToolbox.AUAudioUnitBusArray {
    @objc get
  }
  @objc override dynamic public var internalRenderBlock: AudioToolbox.AUInternalRenderBlock {
    @objc get
  }
  @objc override dynamic public var parameterTree: AudioToolbox.AUParameterTree? {
    @objc get
    @objc set(newValue)
  }
  @objc override dynamic public var canProcessInPlace: Swift.Bool {
    @objc get
  }
  public var dsp: AudioKit.AKDSPRef? {
    get
  }
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
  public var isStarted: Swift.Bool {
    get
  }
  public var rampDuration: Swift.Double {
    get
    set(value)
  }
  open func createDSP() -> AudioKit.AKDSPRef?
  public func start()
  public func stop()
  public func trigger()
  public func triggerFrequency(_ frequency: Swift.Float, amplitude: Swift.Float)
  public func setWavetable(_ wavetable: [Swift.Float], index: Swift.Int = 0)
  public func setWavetable(data: Swift.UnsafePointer<Swift.Float>?, size: Swift.Int, index: Swift.Int = 0)
}
@objc @_inheritsConvenienceInitializers public class AKPWMOscillatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKBandRejectButterworthFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKMusicTrack {
  open var eventData: [AudioKit.AppleMIDIEvent]? {
    get
  }
  open var noteData: [AudioKit.AppleMIDIEvent]? {
    get
  }
  open var programChangeEvents: [AudioKit.MIDIProgramChangeEvent] {
    get
  }
  open func debug()
}
public struct AppleMIDIEvent {
  public var time: AudioToolbox.MusicTimeStamp
  public var type: AudioToolbox.MusicEventType
  public var data: Swift.UnsafeRawPointer?
  public var dataSize: Swift.UInt32
}
public struct MIDIProgramChangeEvent {
  public var time: AudioToolbox.MusicTimeStamp
  public var channel: AudioKit.MIDIChannel
  public var number: AudioKit.MIDIByte
}
@objc @_hasMissingDesignatedInitializers open class AKMIDIClockListener : ObjectiveC.NSObject {
  public var quarterNoteQuantumCounter: Swift.UInt8
  public var quantumCounter: Swift.UInt64
  public var sppMIDIBeatCounter: Swift.UInt64
  public var sppMIDIBeatQuantumCounter: Swift.UInt8
  public var fourCount: Swift.UInt8
  @objc deinit
  @objc override dynamic public init()
}
extension AKMIDIClockListener {
  public func addObserver(_ observer: AudioKit.AKMIDIBeatObserver)
  public func removeObserver(_ observer: AudioKit.AKMIDIBeatObserver)
  public func removeAllObservers()
}
extension AKMIDIClockListener : AudioKit.AKMIDIBeatObserver {
}
extension AKMIDIClockListener : AudioKit.AKMIDITempoObserver {
  public func midiClockSlaveMode()
  public func midiClockMasterEnabled()
}
extension AKMIDIClockListener : AudioKit.AKMIDISystemRealTimeObserver {
  public func stopSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
  public func startSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
  public func continueSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
}
public class AKAmplitudeTap : AudioKit.AKToggleable {
  public var bufferSize: Swift.UInt32 {
    get
  }
  public var isStarted: Swift.Bool {
    get
  }
  public var bus: Swift.Int {
    get
    set(value)
  }
  public var input: AudioKit.AKNode? {
    get
    set(newValue)
  }
  public var amplitude: Swift.Float {
    get
  }
  public var leftAmplitude: Swift.Float {
    get
  }
  public var rightAmplitude: Swift.Float {
    get
  }
  @objc public init(_ input: AudioKit.AKNode?, bufferSize: Swift.UInt32 = 1_024)
  public func start()
  public func stop()
  public func dispose()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AKAudioUnitManager : ObjectiveC.NSObject {
  public enum Notification {
    case effectsAvailable(effects: [AVFoundation.AVAudioUnitComponent])
    case instrumentsAvailable(instruments: [AVFoundation.AVAudioUnitComponent])
    case midiProcessorsAvailable(midiProcessors: [AVFoundation.AVAudioUnitComponent])
    case changed
    case crashed(audioUnit: AudioToolbox.AUAudioUnit?)
  }
  public typealias AKComponentListCallback = ([AVFoundation.AVAudioUnitComponent]) -> Swift.Void
  public typealias AKEffectCallback = (AVFoundation.AVAudioUnit?) -> Swift.Void
  public typealias AKInstrumentCallback = (AVFoundation.AVAudioUnitMIDIInstrument?) -> Swift.Void
  public typealias AKMIDIProcessorCallback = (AVFoundation.AVAudioUnit?) -> Swift.Void
  weak public var delegate: AudioKit.AKAudioUnitManagerDelegate? {
    get
    set(value)
  }
  public var input: AudioKit.AKNode?
  public var output: AudioKit.AKNode?
  public var useSystemAVFormat: Swift.Bool
  public var effectsChain: [AVFoundation.AVAudioUnit?] {
    get
    set(newValue)
  }
  public var linkedEffects: [AVFoundation.AVAudioUnit] {
    get
  }
  public var effectsCount: Swift.Int {
    get
  }
  public var tailTime: Foundation.TimeInterval {
    get
  }
  public var availableEffects: [AVFoundation.AVAudioUnitComponent] {
    get
    set(newValue)
  }
  public var availableInstruments: [AVFoundation.AVAudioUnitComponent] {
    get
    set(newValue)
  }
  public var availableMIDIProcessors: [AVFoundation.AVAudioUnitComponent] {
    get
    set(newValue)
  }
  public convenience init(inserts: Swift.Int)
  @objc override dynamic public init()
  public func requestEffects(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public func requestInstruments(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public func requestMIDIProcessors(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public func createInstrument(name: Swift.String, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKInstrumentCallback)
  public func createEffect(name: Swift.String, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKEffectCallback)
  public func createMIDIProcessor(name: Swift.String, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKMIDIProcessorCallback)
  public func reset()
  public func dispose()
  @objc deinit
}
public protocol AKAudioUnitManagerDelegate : AnyObject {
  func handleAudioUnitManagerNotification(_ notification: AudioKit.AKAudioUnitManager.Notification, audioUnitManager: AudioKit.AKAudioUnitManager)
  func audioUnitManager(_ audioUnitManager: AudioKit.AKAudioUnitManager, didAddEffectAtIndex index: Swift.Int)
  func audioUnitManager(_ audioUnitManager: AudioKit.AKAudioUnitManager, didRemoveEffectAtIndex index: Swift.Int)
}
@objc public protocol ClipMergeDelegate : AnyObject {
  @objc func newClip(from clip: AudioKit.AKClip, time: Swift.Double, offset: Swift.Double, duration: Swift.Double) -> AudioKit.AKClip?
  @objc optional func clipWillBeRemoved(_ clip: AudioKit.AKClip)
}
public enum ClipMergeError : Swift.Error {
  case clipInvalid
  case clipsOverlap
  public static func == (a: AudioKit.ClipMergeError, b: AudioKit.ClipMergeError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers open class AKClipMerger : ObjectiveC.NSObject {
  weak open var mergeDelegate: AudioKit.ClipMergeDelegate?
  @objc open func merge(clip: AudioKit.AKClip, clips: [AudioKit.AKClip]) -> [AudioKit.AKClip]
  open class func validateClips(_ clips: [AudioKit.AKClip]) throws -> [AudioKit.AKClip]
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKFileClipSequence : ObjectiveC.NSObject, AudioKit.ClipMergeDelegate {
  @objc open func newClip(from clip: AudioKit.AKClip, time: Swift.Double, offset: Swift.Double, duration: Swift.Double) -> AudioKit.AKClip?
  @objc open var clips: [AudioKit.AKFileClip] {
    @objc get
    @objc set(newValue)
  }
  @objc open func add(clip: AudioKit.AKFileClip)
  @objc public init(clips: [AudioKit.AKFileClip])
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKVocalTract : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKVocalTractAudioUnit
  public var internalAU: AudioKit.AKVocalTract.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var tonguePositionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var tongueDiameterRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var tensenessRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var nasalityRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultTonguePosition: AudioToolbox.AUValue
  public static var defaultTongueDiameter: AudioToolbox.AUValue
  public static var defaultTenseness: AudioToolbox.AUValue
  public static var defaultNasality: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let tonguePosition: AudioKit.AKNodeParameter
  final public let tongueDiameter: AudioKit.AKNodeParameter
  final public let tenseness: AudioKit.AKNodeParameter
  final public let nasality: AudioKit.AKNodeParameter
  public init(frequency: AudioToolbox.AUValue = defaultFrequency, tonguePosition: AudioToolbox.AUValue = defaultTonguePosition, tongueDiameter: AudioToolbox.AUValue = defaultTongueDiameter, tenseness: AudioToolbox.AUValue = defaultTenseness, nasality: AudioToolbox.AUValue = defaultNasality)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKVocalTract
}
@objc @_inheritsConvenienceInitializers public class AKLowShelfParametricEqualizerFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKWaveTable : AudioKit.AKNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKWaveTableAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKWaveTable.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var startPoint: AudioKit.Sample {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var endPoint: AudioKit.Sample {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var loopStartPoint: AudioKit.Sample {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var loopEndPoint: AudioKit.Sample {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var loopEnabled: Swift.Bool {
    @objc get
    @objc set(value)
  }
  open var size: AudioKit.Sample {
    get
  }
  open var originalSampleRate: Swift.Double? {
    get
  }
  open var normalizedPosition: AudioToolbox.AUValue {
    get
  }
  open var position: AudioToolbox.AUValue {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  open var loadCompletionHandler: () -> Swift.Void {
    get
    set(value)
  }
  open var completionHandler: () -> Swift.Void {
    get
    set(value)
  }
  open var loopCallback: () -> Swift.Void {
    get
    set(value)
  }
  @objc public init(file: AudioKit.AKAudioFile? = nil, startPoint: AudioKit.Sample = 0, endPoint: AudioKit.Sample = 0, rate: AudioToolbox.AUValue = 1, volume: AudioToolbox.AUValue = 1, maximumSamples: AudioKit.Sample, completionHandler: @escaping AudioKit.AKCCallback = {}, loadCompletionHandler: @escaping AudioKit.AKCCallback = {})
  @objc open func start()
  @objc open func stop()
  open func play()
  open func play(from: AudioKit.Sample)
  open func play(from: AudioKit.Sample, length: AudioKit.Sample)
  open func play(from: AudioKit.Sample, to: AudioKit.Sample)
  open func load(file: AudioKit.AKAudioFile)
  @objc deinit
  open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: Swift.Double, channel: AudioKit.MIDIChannel = 0)
  open func stop(noteNumber: AudioKit.MIDINoteNumber)
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKWaveTable
}
@objc @_inheritsConvenienceInitializers public class AKAmplitudeEnvelopeAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKCallbackInstrument : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKCallbackInstrumentAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKCallbackInstrument.AKAudioUnitType? {
    get
  }
  open var callback: (AudioKit.MIDIByte, AudioKit.MIDIByte, AudioKit.MIDIByte) -> Swift.Void {
    get
    set(value)
  }
  @objc public init(midiCallback: AudioKit.AKMIDICallback? = nil)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKCallbackInstrument
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AKSamplerAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public var canProcessInPlace: Swift.Bool {
    @objc get
  }
  public func stopAllVoices()
  public func restartVoices()
  public func loadSampleData(from sampleDataDescriptor: AudioKit.AKSampleDataDescriptor)
  public func loadCompressedSampleFile(from sampleFileDescriptor: AudioKit.AKSampleFileDescriptor)
  public func unloadAllSamples()
  public func setNoteFrequency(noteNumber: Swift.Int32, noteFrequency: Swift.Float)
  public func buildSimpleKeyMap()
  public func buildKeyMap()
  public func setLoop(thruRelease: Swift.Bool)
  public func playNote(noteNumber: Swift.UInt8, velocity: Swift.UInt8)
  public func stopNote(noteNumber: Swift.UInt8, immediate: Swift.Bool)
  public func sustainPedal(down: Swift.Bool)
  @objc deinit
}
@objc open class AKAppleSampler : AudioKit.AKNode {
  public var internalAU: AudioToolbox.AUAudioUnit? {
    get
  }
  public var audioFiles: [AudioKit.AKAudioFile] {
    get
    set(newValue)
  }
  @objc dynamic open var samplerUnit: AVFoundation.AVAudioUnitSampler
  @objc dynamic open var tuning: AudioToolbox.AUValue {
    @objc get
    @objc set(newValue)
  }
  public init(file: Swift.String? = nil)
  @objc open func loadWav(_ file: Swift.String) throws
  @objc open func loadEXS24(_ file: Swift.String) throws
  @objc open func loadAudioFile(_ file: AudioKit.AKAudioFile) throws
  @objc open func loadAudioFiles(_ files: [AudioKit.AKAudioFile]) throws
  @objc open func loadPath(_ filePath: Swift.String) throws
  @objc dynamic open var amplitude: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pan: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open func play(noteNumber: AudioKit.MIDINoteNumber = 60, velocity: AudioKit.MIDIVelocity = 127, channel: AudioKit.MIDIChannel = 0) throws
  @objc open func stop(noteNumber: AudioKit.MIDINoteNumber = 60, channel: AudioKit.MIDIChannel = 0) throws
  @objc public func loadSoundFont(_ file: Swift.String, preset: Swift.Int, bank: Swift.Int) throws
  @objc public func loadMelodicSoundFont(_ file: Swift.String, preset: Swift.Int) throws
  @objc public func loadPercussiveSoundFont(_ file: Swift.String, preset: Swift.Int = 0) throws
  public func setPitchbend(amount: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc @_inheritsConvenienceInitializers public class AKChowningReverbAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public struct EndpointInfo : Swift.Hashable {
  public var name: Swift.String
  public var displayName: Swift.String
  public var model: Swift.String
  public var manufacturer: Swift.String
  public var image: Swift.String
  public var driverOwner: Swift.String
  public var midiUniqueID: CoreMIDI.MIDIUniqueID
  public var midiEndpointRef: CoreMIDI.MIDIEndpointRef
  public var midiPortRef: CoreMIDI.MIDIPortRef?
  public static func == (lhs: AudioKit.EndpointInfo, rhs: AudioKit.EndpointInfo) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AKMIDI {
  public var destinationInfos: [AudioKit.EndpointInfo] {
    get
  }
  public var inputInfos: [AudioKit.EndpointInfo] {
    get
  }
}
public typealias BPM = Swift.Double
public struct AKDuration : Swift.CustomStringConvertible, Swift.Comparable {
  public var beats: Swift.Double
  public var sampleRate: Swift.Double
  public var tempo: Swift.Double
  public var samples: Swift.Int {
    get
    set(newValue)
  }
  public var seconds: Swift.Double {
    get
  }
  public var minutes: Swift.Double {
    get
  }
  public var musicTimeStamp: AudioToolbox.MusicTimeStamp {
    get
  }
  public var description: Swift.String {
    get
  }
  public init(samples: Swift.Int, sampleRate: Swift.Double = AKSettings.sampleRate, tempo: AudioKit.BPM = 60)
  public init(beats: Swift.Double, tempo: AudioKit.BPM = 60)
  public init(seconds: Swift.Double, sampleRate: Swift.Double = AKSettings.sampleRate, tempo: AudioKit.BPM = 60)
  public static func += (lhs: inout AudioKit.AKDuration, rhs: AudioKit.AKDuration)
  public static func -= (lhs: inout AudioKit.AKDuration, rhs: AudioKit.AKDuration)
  public static func == (lhs: AudioKit.AKDuration, rhs: AudioKit.AKDuration) -> Swift.Bool
  public static func < (lhs: AudioKit.AKDuration, rhs: AudioKit.AKDuration) -> Swift.Bool
  public static func + (lhs: AudioKit.AKDuration, rhs: AudioKit.AKDuration) -> AudioKit.AKDuration
  public static func - (lhs: AudioKit.AKDuration, rhs: AudioKit.AKDuration) -> AudioKit.AKDuration
  public static func % (lhs: AudioKit.AKDuration, rhs: AudioKit.AKDuration) -> AudioKit.AKDuration
}
public func ceil(_ duration: AudioKit.AKDuration) -> AudioKit.AKDuration
extension AKTable {
  public class func harmonicPitchRange(rootFrequency: Swift.Double = 8.175_798_915_643_75, octaveStepSize: Swift.Double = 1) -> [(Swift.Double, Swift.Int)]
  public class func harmonicFrequencyRange(f0: Swift.Double = 130.812_782_650_3, f1: Swift.Double = 2_093.004_522_404_8, wavetableCount: Swift.Int = 12) -> [(Swift.Double, Swift.Int)]
  public func sawtooth(harmonicCount: Swift.Int = 1_024, clear: Swift.Bool = true)
  public func square(harmonicCount: Swift.Int = 1_024, clear: Swift.Bool = true)
  public func triangle(harmonicCount: Swift.Int = 1_024, clear: Swift.Bool = true)
  public func pwm(harmonicCount: Swift.Int = 1_024, period: Swift.Float = 1 / 8)
  public func minMax() -> (min: Swift.Float, max: Swift.Float, absMax: Swift.Float)
  public func normalize()
  public func reverse()
  public func invert()
  public func msd(t: AudioKit.AKTable) -> AudioKit.AKTable.Element
}
@objc open class AKSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKSynth.AKAudioUnitType? {
    get
  }
  @objc open var masterVolume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterCutoff: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  public init(masterVolume: AudioToolbox.AUValue = 1.0, pitchBend: AudioToolbox.AUValue = 0.0, vibratoDepth: AudioToolbox.AUValue = 0.0, filterCutoff: AudioToolbox.AUValue = 4.0, filterStrength: AudioToolbox.AUValue = 20.0, filterResonance: AudioToolbox.AUValue = 0.0, attackDuration: AudioToolbox.AUValue = 0.0, decayDuration: AudioToolbox.AUValue = 0.0, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.0, filterEnable: Swift.Bool = false, filterAttackDuration: AudioToolbox.AUValue = 0.0, filterDecayDuration: AudioToolbox.AUValue = 0.0, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 0.0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  open func silence(noteNumber: AudioKit.MIDINoteNumber)
  open func sustainPedal(pedalDown: Swift.Bool)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKSynth
}
extension AKAudioUnitManager {
  public func insertAudioUnit(name: Swift.String, at index: Swift.Int)
  public func removeEffect(at index: Swift.Int, reconnectChain: Swift.Bool = true)
  public func removeEffects()
  open func connectEffects(firstNode: AudioKit.AKNode? = nil, lastNode: AudioKit.AKNode? = nil)
}
extension AKTuningTable {
  public func defaultTuning() -> Swift.Int
  public func twelveToneEqualTemperament() -> Swift.Int
  public func thirtyOneEqualTemperament() -> Swift.Int
  public func equalTemperament(notesPerOctave npo: Swift.Int) -> Swift.Int
}
@objc @_inheritsConvenienceInitializers public class AKSequencerEngineAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKComputedParameter {
  public func pitchShift(semitones: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func sineWave(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 1) -> AudioKit.AKOperation
}
extension AKOperation {
  public func minus(_ subtrahend: AudioKit.AKParameter) -> AudioKit.AKOperation
}
public func - (left: AudioKit.AKParameter, right: AudioKit.AKParameter) -> AudioKit.AKOperation
public func - (first: AudioKit.AKStereoOperation, second: AudioKit.AKStereoOperation) -> AudioKit.AKStereoOperation
prefix public func - (x: AudioKit.AKParameter) -> AudioKit.AKOperation
prefix public func - (x: AudioKit.AKStereoOperation) -> AudioKit.AKStereoOperation
@objc open class AKEqualizerFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKEqualizerFilterAudioUnit
  public var internalAU: AudioKit.AKEqualizerFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var bandwidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var gainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultBandwidth: AudioToolbox.AUValue
  public static var defaultGain: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let bandwidth: AudioKit.AKNodeParameter
  final public let gain: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, bandwidth: AudioToolbox.AUValue = defaultBandwidth, gain: AudioToolbox.AUValue = defaultGain)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKEqualizerFilter
}
extension AKOperation {
  public func portamento(halfDuration: AudioKit.AKParameter = 0.02) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func reverberateWithChowning() -> AudioKit.AKOperation
}
extension AKOperation {
  public static func metronome(frequency: AudioKit.AKParameter = 2.0) -> AudioKit.AKOperation
}
public typealias BPMType = Foundation.TimeInterval
@objc open class AKMIDITempoListener : ObjectiveC.NSObject {
  public var clockListener: AudioKit.AKMIDIClockListener?
  public var srtListener: AudioKit.AKMIDISystemRealTimeListener
  public var tempoString: Swift.String
  public var tempo: Swift.Double
  public var incomingClockActive: Swift.Bool
  @objc public init(smoothing: Swift.Float64 = 0.8, bpmHistoryLimit: Swift.Int = 3)
  @objc deinit
  @objc override dynamic public init()
}
extension AKMIDITempoListener {
  public func analyze()
  public func resetClockEventsLeavingOne()
  public func resetClockEventsLeavingHalf()
  public func resetClockEventsLeavingNone()
}
extension AKMIDITempoListener : AudioKit.AKMIDIListener {
  public func receivedMIDISystemCommand(_ data: [AudioKit.MIDIByte], portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
}
extension AKMIDITempoListener {
  public func addObserver(_ observer: AudioKit.AKMIDITempoObserver)
  public func removeObserver(_ observer: AudioKit.AKMIDITempoObserver)
  public func removeAllObserver()
}
extension AVAudioEngine {
  open func connect(_ node1: AVFoundation.AVAudioNode, to node2: AVFoundation.AVAudioNode)
  @available(iOS 11.0, OSX 10.13, tvOS 11.0, *)
  public func renderToFile(_ audioFile: AVFoundation.AVAudioFile, maximumFrameCount: AVFoundation.AVAudioFrameCount = 4_096, duration: Swift.Double, prerender: (() -> Swift.Void)? = nil, progress: ((Swift.Double) -> Swift.Void)? = nil) throws
}
public typealias AKCallback = () -> Swift.Void
public typealias AKMIDICallback = (AudioKit.MIDIByte, AudioKit.MIDIByte, AudioKit.MIDIByte) -> Swift.Void
@objc @_inheritsConvenienceInitializers open class AKManager : ObjectiveC.NSObject {
  public static var deviceSampleRate: Swift.Double
  @objc public static var engine: AVFoundation.AVAudioEngine {
    @objc get
    @objc set(newValue)
  }
  public static var midi: AudioKit.AKMIDI
  @objc public static var output: AudioKit.AKNode? {
    @objc get
    @objc set(value)
  }
  @objc public static var devices: [AudioKit.AKDevice]? {
    @objc get
  }
  @objc public static var inputDevices: [AudioKit.AKDevice]? {
    @objc get
  }
  @objc public static var outputDevices: [AudioKit.AKDevice]? {
    @objc get
  }
  @objc public static var inputDevice: AudioKit.AKDevice? {
    @objc get
  }
  @objc public static var outputDevice: AudioKit.AKDevice? {
    @objc get
  }
  @objc public static func setInputDevice(_ input: AudioKit.AKDevice) throws
  @objc public static func setOutputDevice(_ output: AudioKit.AKDevice) throws
  @objc public static func disconnectAllInputs()
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKFrequencyTracker : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKFrequencyTrackerAudioUnit
  public var internalAU: AudioKit.AKFrequencyTracker.AKAudioUnitType? {
    get
  }
  @objc dynamic open var amplitude: Swift.Double {
    @objc get
  }
  @objc dynamic open var frequency: Swift.Double {
    @objc get
  }
  public init(_ input: AudioKit.AKNode? = nil, hopSize: Swift.Int = 4_096, peakCount: Swift.Int = 20)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFrequencyTracker
}
extension UInt8 {
  public var lowBit: AudioKit.MIDIByte {
    get
  }
  public var highBit: AudioKit.MIDIByte {
    get
  }
  public var hex: Swift.String {
    get
  }
}
public enum MIDITimeFormat : Swift.Int {
  case ticksPerBeat
  case framesPerSecond
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum AKMIDIControl : AudioKit.MIDIByte {
  case modulationWheel
  case breathControl
  case footControl
  case portamento
  case dataEntry
  case mainVolume
  case balance
  case pan
  case expression
  case damperOnOff
  case portamentoOnOff
  case sustenutoOnOff
  case softPedalOnOff
  case soundVariation
  case resonance
  case releaseTime
  case attackTime
  case cutoff
  case soundControl6
  case soundControl7
  case soundControl8
  case soundControl9
  case soundControl10
  case gpButton1
  case gpButton2
  case gpButton3
  case gpButton4
  case reverbLevel
  case tremoloLevel
  case chorusLevel
  case celesteLevel
  case phaserLevel
  case dataEntryPlus
  case dataEntryMinus
  case NrpnLsb
  case NrpnMsb
  case RpnLsb
  case RpnMsb
  case allSoundsOff
  case allControllersOff
  case localControlOnOff
  case allNotesOff
  case omniModeOff
  case omniModeOn
  case monoOperation
  case polyOperation
  case cc0
  case cc3
  case cc9
  case cc12
  case cc13
  case cc14
  case cc15
  case cc16
  case cc17
  case cc18
  case cc19
  case cc20
  case cc21
  case cc22
  case cc23
  case cc24
  case cc25
  case cc26
  case cc27
  case cc28
  case cc29
  case cc30
  case cc31
  case cc32
  case modulationWheelLsb
  case breathControllerLsb
  case footControlLsb
  case portamentoLsb
  case dataEntryLsb
  case mainVolumeLsb
  case balanceLsb
  case panLsb
  case expressionLsb
  case effectControl1Lsb
  case effectControl2Lsb
  public typealias RawValue = AudioKit.MIDIByte
  public init?(rawValue: AudioKit.MIDIByte)
  public var rawValue: AudioKit.MIDIByte {
    get
  }
}
public func AKTry(_ operation: @escaping (() throws -> Swift.Void)) throws
@objc @_inheritsConvenienceInitializers public class AKDynamicPlayer : AudioKit.AKPlayer {
  public var timePitchNode: AudioKit.AKTimePitch? {
    get
  }
  public var rate: AudioToolbox.AUValue {
    get
    set(newValue)
  }
  public var pitch: AudioToolbox.AUValue {
    get
    set(newValue)
  }
  override open func initialize(restartIfPlaying: Swift.Bool = true)
  public func createTimePitch()
  public func removeTimePitch()
  override public func play(from startingTime: Swift.Double, to endingTime: Swift.Double, at audioTime: AVFoundation.AVAudioTime?, hostTime: Swift.UInt64?)
  @objc override public func stop()
  @objc override public func detach()
  @objc deinit
  override public init()
}
@objc @_inheritsConvenienceInitializers public class AKPannerAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKMIDITimeout : ObjectiveC.NSObject {
  public typealias ActionClosureType = () -> Swift.Void
  public init(timeoutInterval time: Foundation.TimeInterval, onMainThread: Swift.Bool = true, success: @escaping AudioKit.AKMIDITimeout.ActionClosureType, timeout: @escaping AudioKit.AKMIDITimeout.ActionClosureType)
  @objc deinit
  public func perform(_ block: () -> Swift.Void)
  public func succeed()
  @objc override dynamic public init()
}
extension AKOperation {
  public func triggeredWithEnvelope(trigger: AudioKit.AKParameter, attack: AudioKit.AKParameter = 0.1, hold: AudioKit.AKParameter = 0.3, release: AudioKit.AKParameter = 0.2) -> AudioKit.AKOperation
}
public protocol AKMIDITempoObserver {
  func midiClockSlaveMode()
  func midiClockMasterEnabled()
  func receivedTempo(bpm: AudioKit.BPMType, label: Swift.String)
}
extension AKMIDITempoObserver {
  public func midiClockSlaveMode()
  public func midiClockMasterEnabled()
  public func receivedTempo(bpm: AudioKit.BPMType, label: Swift.String)
  public func isEqualTo(_ listener: AudioKit.AKMIDITempoObserver) -> Swift.Bool
}
@objc public class AKPlayer : AudioKit.AKAbstractPlayer {
  public enum BufferingType {
    case dynamic
    case always
    public static func == (a: AudioKit.AKPlayer.BufferingType, b: AudioKit.AKPlayer.BufferingType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @objc public var playerNode: AVFoundation.AVAudioPlayerNode
  @objc public var mixerNode: AVFoundation.AVAudioMixerNode?
  @objc public var completionHandler: AudioKit.AKCallback? {
    @objc get
    @objc set(value)
  }
  @objc public var loopCompletionHandler: AudioKit.AKCallback?
  @objc public var buffer: AVFoundation.AVAudioPCMBuffer?
  public var buffering: AudioKit.AKPlayer.BufferingType {
    get
    set(value)
  }
  override public var renderingMode: AudioKit.AKAbstractPlayer.RenderingMode {
    get
  }
  @objc public var audioFile: AVFoundation.AVAudioFile? {
    get
  }
  @objc override public var duration: Swift.Double {
    @objc get
  }
  @objc override public var sampleRate: Swift.Double {
    @objc get
  }
  @objc public var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(newValue)
  }
  @objc public var pan: AudioToolbox.AUValue {
    @objc get
    @objc set(newValue)
  }
  @objc public var frameCount: AVFoundation.AVAudioFrameCount {
    get
  }
  @objc public var currentFrame: AVFoundation.AVAudioFramePosition {
    @objc get
  }
  @objc public var currentTime: Swift.Double {
    @objc get
  }
  public var pauseTime: Swift.Double? {
    get
    set(value)
  }
  @objc public var processingFormat: AVFoundation.AVAudioFormat? {
    @objc get
  }
  @objc public var isBuffered: Swift.Bool {
    @objc get
  }
  @objc public var isNormalized: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc public var isPaused: Swift.Bool {
    get
  }
  @objc public var isReversed: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc public var isBufferFaded: Swift.Bool {
    @objc get
  }
  public init()
  @objc public convenience init?(url: Foundation.URL)
  @objc public convenience init(audioFile: AVFoundation.AVAudioFile, reopenFile: Swift.Bool = true)
  override open func initialize(restartIfPlaying: Swift.Bool = true)
  @objc override public func play()
  public func play(from startingTime: Swift.Double, to endingTime: Swift.Double, at audioTime: AVFoundation.AVAudioTime?, hostTime: Swift.UInt64?)
  @objc override public func stop()
  @objc override public func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc @_inheritsConvenienceInitializers public class AKThreePoleLowpassFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKBoosterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKDynamicRangeCompressor : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKDynamicRangeCompressorAudioUnit
  public var internalAU: AudioKit.AKDynamicRangeCompressor.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var ratioRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var thresholdRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var attackDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var releaseDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultRatio: AudioToolbox.AUValue
  public static var defaultThreshold: AudioToolbox.AUValue
  public static var defaultAttackDuration: AudioToolbox.AUValue
  public static var defaultReleaseDuration: AudioToolbox.AUValue
  final public let ratio: AudioKit.AKNodeParameter
  final public let threshold: AudioKit.AKNodeParameter
  final public let attackDuration: AudioKit.AKNodeParameter
  final public let releaseDuration: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, ratio: AudioToolbox.AUValue = defaultRatio, threshold: AudioToolbox.AUValue = defaultThreshold, attackDuration: AudioToolbox.AUValue = defaultAttackDuration, releaseDuration: AudioToolbox.AUValue = defaultReleaseDuration)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDynamicRangeCompressor
}
@objc @_inheritsConvenienceInitializers public class AKStereoDelayAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AVAudioTime {
  open func extrapolateTimeShimmed(fromAnchor anchorTime: AVFoundation.AVAudioTime) -> AVFoundation.AVAudioTime
  public static func now() -> AVFoundation.AVAudioTime
  open func offset(seconds: Swift.Double) -> AVFoundation.AVAudioTime
  open func timeIntervalSince(otherTime: AVFoundation.AVAudioTime) -> Swift.Double?
  open func toSeconds(hostTime time: Swift.UInt64) -> Swift.Double
  open class func secondsToAudioTime(hostTime: Swift.UInt64, time: Swift.Double) -> AVFoundation.AVAudioTime
}
public func + (left: AVFoundation.AVAudioTime, right: Swift.Double) -> AVFoundation.AVAudioTime
public func + (left: AVFoundation.AVAudioTime, right: Swift.Int) -> AVFoundation.AVAudioTime
public func - (left: AVFoundation.AVAudioTime, right: Swift.Double) -> AVFoundation.AVAudioTime
public func - (left: AVFoundation.AVAudioTime, right: Swift.Int) -> AVFoundation.AVAudioTime
extension AKTuningTable {
  @discardableResult
  @objc dynamic public func hexany(_ A: AudioKit.AKTuningTable.Frequency, _ B: AudioKit.AKTuningTable.Frequency, _ C: AudioKit.AKTuningTable.Frequency, _ D: AudioKit.AKTuningTable.Frequency) -> Swift.Int
  @discardableResult
  @objc dynamic public func majorTetrany(_ A: AudioKit.AKTuningTable.Frequency, _ B: AudioKit.AKTuningTable.Frequency, _ C: AudioKit.AKTuningTable.Frequency, _ D: AudioKit.AKTuningTable.Frequency) -> Swift.Int
  @discardableResult
  @objc dynamic public func minorTetrany(_ A: AudioKit.AKTuningTable.Frequency, _ B: AudioKit.AKTuningTable.Frequency, _ C: AudioKit.AKTuningTable.Frequency, _ D: AudioKit.AKTuningTable.Frequency) -> Swift.Int
}
public struct AKMIDINoteData : Swift.CustomStringConvertible, Swift.Equatable {
  public var noteNumber: AudioKit.MIDINoteNumber
  public var velocity: AudioKit.MIDIVelocity
  public var channel: AudioKit.MIDIChannel
  public var duration: AudioKit.AKDuration
  public var position: AudioKit.AKDuration
  public init(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, duration: AudioKit.AKDuration, position: AudioKit.AKDuration)
  public var description: Swift.String {
    get
  }
  public static func == (a: AudioKit.AKMIDINoteData, b: AudioKit.AKMIDINoteData) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class AKCostelloReverbAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public protocol AKMIDITransformer {
  func transform(eventList: [AudioKit.AKMIDIEvent]) -> [AudioKit.AKMIDIEvent]
}
extension AKMIDITransformer {
  public func transform(eventList: [AudioKit.AKMIDIEvent]) -> [AudioKit.AKMIDIEvent]
  public func isEqualTo(_ transformer: AudioKit.AKMIDITransformer) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class AKModalResonanceFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKClipPlayer : AudioKit.AKNode {
  final public let playerNode: AVFoundation.AVAudioPlayerNode
  open var currentTime: Swift.Double {
    get
    set(newValue)
  }
  open var isPlaying: Swift.Bool {
    get
  }
  open func setClips(clips: [AudioKit.FileClip]) throws
  open var clips: [AudioKit.FileClip] {
    get
    set(newValue)
  }
  public convenience init?(clips: [AudioKit.FileClip])
  public init(clips: [AudioKit.FileClip]? = nil)
  open func prepare(withFrameCount frameCount: AVFoundation.AVAudioFrameCount)
  open func play()
  open func play(at audioTime: AVFoundation.AVAudioTime?)
  @objc open func stop()
  open var volume: Swift.Float {
    get
    set(newValue)
  }
  open var pan: Swift.Float {
    get
    set(newValue)
  }
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
extension AKClipPlayer : AudioKit.AKTiming {
  @objc dynamic public var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open func start(at audioTime: AVFoundation.AVAudioTime? = nil)
  @objc dynamic open func setPosition(_ position: Swift.Double)
  @objc dynamic open func position(at audioTime: AVFoundation.AVAudioTime?) -> Swift.Double
  @objc dynamic open func audioTime(at time: Swift.Double) -> AVFoundation.AVAudioTime?
  @objc dynamic open func prepare()
}
@objc open class AKSequencerTrack : AudioKit.AKNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKSequencerEngineAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKSequencerTrack.AKAudioUnitType? {
    get
  }
  public var targetNode: AudioKit.AKNode?
  public var length: Swift.Double {
    get
    set(newValue)
  }
  public var tempo: AudioKit.BPM {
    get
    set(newValue)
  }
  public var maximumPlayCount: Swift.Double {
    get
    set(newValue)
  }
  public var loopEnabled: Swift.Bool {
    get
    set(newValue)
  }
  public var isPlaying: Swift.Bool {
    get
  }
  public var currentPosition: Swift.Double {
    get
  }
  @objc public init(targetNode: AudioKit.AKNode?)
  public func setTarget(node: AudioKit.AKNode)
  public func play()
  public func playFromStart()
  public func playAfterDelay(beats: Swift.Double)
  public func stop()
  public func rewind()
  public func seek(to position: Swift.Double)
  open func add(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity = 127, channel: AudioKit.MIDIChannel = 0, position: Swift.Double, duration: Swift.Double)
  open func add(status: AudioKit.AKMIDIStatus, data1: Swift.UInt8, data2: Swift.UInt8, position: Swift.Double)
  open func add(event: AudioKit.AKMIDIEvent, position: Swift.Double)
  open func removeEvent(at position: Swift.Double)
  open func removeNote(at position: Swift.Double)
  open func removeNote(noteNumber: AudioKit.MIDINoteNumber, position: Swift.Double)
  open func removeAllInstancesOf(noteNumber: AudioKit.MIDINoteNumber)
  open func clear()
  open func stopPlayingNotes()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKSequencerTrack
}
extension AKTuningTable {
  @discardableResult
  @objc dynamic public func khiasmos22Indian() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian00_17() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian01Kalyan() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian02Bilawal() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian03Khamaj() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian04KafiOld() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian05Kafi() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian06Asawari() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian07Bhairavi() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian08Marwa() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian09Purvi() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian10Lalit2() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian11Todi() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian12Lalit() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian13NoName() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian14AnandBhairav() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian15Bhairav() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian16JogiyaTodi() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian17Madhubanti() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian18NatBhairav() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian19AhirBhairav() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian20ChandraKanada() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian21BasantMukhari() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian22Champakali() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian23Patdeep() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian24MohanKauns() -> Swift.Int
  @discardableResult
  @objc dynamic public func presetPersian17NorthIndian25Parameswari() -> Swift.Int
}
@objc @_inheritsConvenienceInitializers public class AKDCBlockAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKCombFilterReverbAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AKMIDISystemRealTimeListener : ObjectiveC.NSObject {
  public enum SRTState {
    case stopped
    case playing
    case paused
    public static func == (a: AudioKit.AKMIDISystemRealTimeListener.SRTState, b: AudioKit.AKMIDISystemRealTimeListener.SRTState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @objc deinit
  @objc override dynamic public init()
}
extension AKMIDISystemRealTimeListener : AudioKit.AKMIDIListener {
  public func receivedMIDISystemCommand(_ data: [AudioKit.MIDIByte], offset: CoreMIDI.MIDITimeStamp = 0)
}
extension AKMIDISystemRealTimeListener {
  public func addObserver(_ observer: AudioKit.AKMIDISystemRealTimeObserver)
  public func removeObserver(_ observer: AudioKit.AKMIDISystemRealTimeObserver)
  public func removeAllObserver(_ observer: AudioKit.AKMIDISystemRealTimeObserver)
}
@objc @_inheritsConvenienceInitializers public class AKFormantFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKManager {
  public static func start(withPeriodicFunctions functions: AudioKit.AKPeriodicFunction...) throws
  @objc public static func start() throws
  @objc public static func stop() throws
  @objc public static func shutdown() throws
}
extension AKPlayer {
  @objc dynamic public func load(url: Foundation.URL) throws
  @objc dynamic public func load(audioFile: AVFoundation.AVAudioFile) throws
  @objc dynamic public func preroll(from startingTime: Swift.Double = 0, to endingTime: Swift.Double = 0)
}
extension AKPlayer {
  @objc dynamic public func play(from startingTime: Swift.Double, to endingTime: Swift.Double = 0)
  @objc dynamic public func play(at audioTime: AVFoundation.AVAudioTime?)
  public func play(at audioTime: AVFoundation.AVAudioTime?, hostTime: Swift.UInt64?)
  public func play(when scheduledTime: Swift.Double, hostTime: Swift.UInt64? = nil)
  public func play(from startingTime: Swift.Double, to endingTime: Swift.Double, when scheduledTime: Swift.Double, hostTime: Swift.UInt64? = nil)
  @objc dynamic public func pause()
  @objc dynamic public func resume()
  public func fadeOutAndStop(time: Foundation.TimeInterval)
}
@objc extension AKPlayer : AudioKit.AKTiming {
  @objc dynamic public func start(at audioTime: AVFoundation.AVAudioTime?)
  @objc dynamic public var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic public func setPosition(_ position: Swift.Double)
  @objc dynamic public func position(at audioTime: AVFoundation.AVAudioTime?) -> Swift.Double
  @objc dynamic public func audioTime(at position: Swift.Double) -> AVFoundation.AVAudioTime?
  @objc dynamic open func prepare()
}
@objc @_inheritsConvenienceInitializers public class AKPitchShifterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKMIDI {
  open func createVirtualPorts(_ uniqueID: Swift.Int32 = 2_000_000, name: Swift.String? = nil)
  open func createVirtualInputPort(_ uniqueID: Swift.Int32 = 2_000_000, name: Swift.String? = nil)
  open func createVirtualOutputPort(_ uniqueID: Swift.Int32 = 2_000_001, name: Swift.String? = nil)
  open func destroyVirtualPorts()
  @discardableResult
  open func destroyVirtualInputPort() -> Swift.Bool
  @discardableResult
  open func destroyVirtualOutputPort() -> Swift.Bool
}
@objc open class AKPhaser : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPhaserAudioUnit
  public var internalAU: AudioKit.AKPhaser.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var notchMinimumFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var notchMaximumFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var notchWidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var notchFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var vibratoModeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var depthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var invertedRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var lfoBPMRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultNotchMinimumFrequency: AudioToolbox.AUValue
  public static var defaultNotchMaximumFrequency: AudioToolbox.AUValue
  public static var defaultNotchWidth: AudioToolbox.AUValue
  public static var defaultNotchFrequency: AudioToolbox.AUValue
  public static var defaultVibratoMode: AudioToolbox.AUValue
  public static var defaultDepth: AudioToolbox.AUValue
  public static var defaultFeedback: AudioToolbox.AUValue
  public static var defaultInverted: AudioToolbox.AUValue
  public static var defaultLfoBPM: AudioToolbox.AUValue
  final public let notchMinimumFrequency: AudioKit.AKNodeParameter
  final public let notchMaximumFrequency: AudioKit.AKNodeParameter
  final public let notchWidth: AudioKit.AKNodeParameter
  final public let notchFrequency: AudioKit.AKNodeParameter
  final public let vibratoMode: AudioKit.AKNodeParameter
  final public let depth: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  final public let inverted: AudioKit.AKNodeParameter
  final public let lfoBPM: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, notchMinimumFrequency: AudioToolbox.AUValue = defaultNotchMinimumFrequency, notchMaximumFrequency: AudioToolbox.AUValue = defaultNotchMaximumFrequency, notchWidth: AudioToolbox.AUValue = defaultNotchWidth, notchFrequency: AudioToolbox.AUValue = defaultNotchFrequency, vibratoMode: AudioToolbox.AUValue = defaultVibratoMode, depth: AudioToolbox.AUValue = defaultDepth, feedback: AudioToolbox.AUValue = defaultFeedback, inverted: AudioToolbox.AUValue = defaultInverted, lfoBPM: AudioToolbox.AUValue = defaultLfoBPM)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPhaser
}
@objc open class AKSpeechSynthesizer : AudioKit.AKNode {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var rate: Swift.Int {
    get
    set(newRate)
  }
  public var frequency: Swift.Int {
    get
    set(newFrequency)
  }
  public var modulation: Swift.Int {
    get
    set(newModulation)
  }
  public func stop()
  public func say(text: Swift.String, rate: Swift.Int? = nil, frequency: Swift.Int? = nil, modulation: Swift.Int? = nil)
  @objc public init(rate: Swift.Int = 200, frequency: Swift.Int = 200, modulation: Swift.Int = 0)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKInputConnection : ObjectiveC.NSObject {
  open var node: AudioKit.AKInput
  open var bus: Swift.Int
  public init(node: AudioKit.AKInput, bus: Swift.Int)
  open var avConnection: AVFoundation.AVAudioConnectionPoint {
    get
  }
  @objc deinit
  @objc override dynamic public init()
}
@objc public protocol AKOutput : AnyObject {
  @objc var outputNode: AVFoundation.AVAudioNode { get }
}
extension AKOutput {
  public var connectionPoints: [AVFoundation.AVAudioConnectionPoint] {
    get
    set(newValue)
  }
  public func disconnectOutput()
  public func disconnectOutput(from: AudioKit.AKInput)
  @discardableResult
  public func connect(to node: AudioKit.AKInput) -> AudioKit.AKInput
  @discardableResult
  public func connect(to input: AudioKit.AKInputConnection) -> AudioKit.AKInput
  @discardableResult
  public func connect(to node: AudioKit.AKInput, bus: Swift.Int) -> AudioKit.AKInput
  @discardableResult
  public func connect(to nodes: [AudioKit.AKInput]) -> [AudioKit.AKInput]
  @discardableResult
  public func connect(toInputs: [AudioKit.AKInputConnection]) -> [AudioKit.AKInput]
  public func connect(to connectionPoint: AVFoundation.AVAudioConnectionPoint)
  @discardableResult
  public func setOutput(to node: AudioKit.AKInput) -> AudioKit.AKInput
  @discardableResult
  public func setOutput(to node: AudioKit.AKInput, bus: Swift.Int, format: AVFoundation.AVAudioFormat?) -> AudioKit.AKInput
  @discardableResult
  public func setOutput(to nodes: [AudioKit.AKInput], format: AVFoundation.AVAudioFormat?) -> [AudioKit.AKInput]
  @discardableResult
  public func setOutput(toInputs: [AudioKit.AKInputConnection]) -> [AudioKit.AKInput]
  @discardableResult
  public func setOutput(toInputs: [AudioKit.AKInputConnection], format: AVFoundation.AVAudioFormat?) -> [AudioKit.AKInput]
  public func setOutput(to connectionPoint: AVFoundation.AVAudioConnectionPoint)
  public func setOutput(to connectionPoint: AVFoundation.AVAudioConnectionPoint, format: AVFoundation.AVAudioFormat?)
  public func setOutput(to connectionPoints: [AVFoundation.AVAudioConnectionPoint], format: AVFoundation.AVAudioFormat?)
}
public protocol AKInput : AudioKit.AKOutput {
  var inputNode: AVFoundation.AVAudioNode { get }
  var nextInput: AudioKit.AKInputConnection { get }
  func disconnectInput()
  func disconnectInput(bus: Swift.Int)
  func input(_ bus: Swift.Int) -> AudioKit.AKInputConnection
}
extension AKInput {
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  public func disconnectInput()
  public func disconnectInput(bus: Swift.Int)
  public var nextInput: AudioKit.AKInputConnection {
    get
  }
  public func input(_ bus: Swift.Int) -> AudioKit.AKInputConnection
}
@objc extension AVAudioNode : AudioKit.AKInput {
  @objc dynamic public var outputNode: AVFoundation.AVAudioNode {
    @objc get
  }
}
infix operator >>> : AdditionPrecedence
@discardableResult
public func >>> (left: AudioKit.AKOutput, right: AudioKit.AKInput) -> AudioKit.AKInput
@discardableResult
public func >>> (left: AudioKit.AKOutput, right: [AudioKit.AKInput]) -> [AudioKit.AKInput]
@discardableResult
public func >>> (left: [AudioKit.AKOutput], right: AudioKit.AKInput) -> AudioKit.AKInput
@discardableResult
public func >>> (left: AudioKit.AKOutput, right: AudioKit.AKInputConnection) -> AudioKit.AKInput
@discardableResult
public func >>> (left: AudioKit.AKOutput, right: [AudioKit.AKInputConnection]) -> [AudioKit.AKInput]
public func >>> (left: AudioKit.AKOutput, right: AVFoundation.AVAudioConnectionPoint)
@objc open class AKNodeRecorder : ObjectiveC.NSObject {
  public var node: AudioKit.AKNode? {
    get
  }
  @objc dynamic public var isRecording: Swift.Bool {
    get
  }
  @objc open var durationToRecord: Swift.Double
  @objc open var recordedDuration: Swift.Double {
    @objc get
  }
  open var recordFormat: AVFoundation.AVAudioFormat?
  @objc open var audioFile: AudioKit.AKAudioFile? {
    @objc get
  }
  @objc public init(node: AudioKit.AKNode? = AKManager.output, file: AudioKit.AKAudioFile? = nil, bus: Swift.Int = 0) throws
  @objc open func record() throws
  @objc open func stop()
  @objc open func reset() throws
  @objc deinit
  @objc override dynamic public init()
}
extension AKTuningTable {
  @discardableResult
  public func presetRecurrenceRelation01() -> Swift.Int
}
@objc open class AKOscillator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKOscillatorAudioUnit
  public var internalAU: AudioKit.AKOscillator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningOffsetRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultDetuningOffset: AudioToolbox.AUValue
  public static var defaultDetuningMultiplier: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  final public let detuningOffset: AudioKit.AKNodeParameter
  final public let detuningMultiplier: AudioKit.AKNodeParameter
  public init(waveform: AudioKit.AKTable = AKTable(.sine), frequency: AudioToolbox.AUValue = defaultFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude, detuningOffset: AudioToolbox.AUValue = defaultDetuningOffset, detuningMultiplier: AudioToolbox.AUValue = defaultDetuningMultiplier)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKOscillator
}
@objc open class AKDistortion : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var delay: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decay: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var delayMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decimation: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rounding: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decimationMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var linearTerm: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var squaredTerm: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var cubicTerm: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var polynomialMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var ringModFreq1: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var ringModFreq2: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var ringModBalance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var ringModMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var softClipGain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var finalMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, delay: AudioToolbox.AUValue = 0.1, decay: AudioToolbox.AUValue = 1.0, delayMix: AudioToolbox.AUValue = 0.5, decimation: AudioToolbox.AUValue = 0.5, rounding: AudioToolbox.AUValue = 0.0, decimationMix: AudioToolbox.AUValue = 0.5, linearTerm: AudioToolbox.AUValue = 0.5, squaredTerm: AudioToolbox.AUValue = 0.5, cubicTerm: AudioToolbox.AUValue = 0.5, polynomialMix: AudioToolbox.AUValue = 0.5, ringModFreq1: AudioToolbox.AUValue = 100, ringModFreq2: AudioToolbox.AUValue = 100, ringModBalance: AudioToolbox.AUValue = 0.5, ringModMix: AudioToolbox.AUValue = 0.0, softClipGain: AudioToolbox.AUValue = -6, finalMix: AudioToolbox.AUValue = 0.5)
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDistortion
}
@objc @_inheritsConvenienceInitializers open class AKTuningTableBase : ObjectiveC.NSObject {
  public typealias Frequency = Swift.Double
  public typealias Cents = Swift.Double
  public static var NYQUIST: Swift.Double
  @objc public static var midiNoteCount: Swift.Int
  @objc override dynamic public init()
  @objc public var npo: Swift.Int {
    @objc get
  }
  @objc public func frequency(forNoteNumber noteNumber: AudioKit.MIDINoteNumber) -> AudioKit.AKTuningTableBase.Frequency
  @objc public func setFrequency(_ frequency: AudioKit.AKTuningTableBase.Frequency, at noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
}
@objc open class AKBandRejectButterworthFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKBandRejectButterworthFilterAudioUnit
  public var internalAU: AudioKit.AKBandRejectButterworthFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var bandwidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultBandwidth: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let bandwidth: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, bandwidth: AudioToolbox.AUValue = defaultBandwidth)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBandRejectButterworthFilter
}
@objc @_inheritsConvenienceInitializers public class AKPinkNoiseAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public enum AKMIDISystemCommand : AudioKit.MIDIByte, AudioKit.AKMIDIMessage {
  case sysex
  case timeCodeQuarterFrame
  case songPosition
  case songSelect
  case tuneRequest
  case sysexEnd
  case clock
  case start
  case `continue`
  case stop
  case activeSensing
  case sysReset
  public var description: Swift.String {
    get
  }
  public var byte: AudioKit.MIDIByte {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public typealias RawValue = AudioKit.MIDIByte
  public init?(rawValue: AudioKit.MIDIByte)
  public var rawValue: AudioKit.MIDIByte {
    get
  }
}
public enum AKMIDISystemCommandType {
  case systemRealtime
  case systemCommon
  case systemExclusive
  public static func == (a: AudioKit.AKMIDISystemCommandType, b: AudioKit.AKMIDISystemCommandType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension AKOperation {
  public func gatedADSREnvelope(gate: AudioKit.AKParameter, attack: AudioKit.AKParameter = 0.1, decay: AudioKit.AKParameter = 0.0, sustain: AudioKit.AKParameter = 1, release: AudioKit.AKParameter = 0.2) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKFaderAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension OSLog {
  public static var general: os.OSLog
  public static var settings: os.OSLog
  public static var midi: os.OSLog
  public static var fileHandling: os.OSLog
}
@inline(__always) public func AKLog(_ items: Any?..., log: os.OSLog = OSLog.general, type: os.OSLogType = .info, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line)
extension AKComputedParameter {
  public func stringResonator(frequency: AudioKit.AKParameter = 100.0, feedback: AudioKit.AKParameter = 0.95) -> AudioKit.AKOperation
}
extension AKSampler {
  open func loadSFZ(path: Swift.String, fileName: Swift.String)
  open func loadSFZ(url: Foundation.URL)
}
extension AKOperation {
  public static func randomNumberPulse(minimum: AudioKit.AKParameter = 0, maximum: AudioKit.AKParameter = 1, updateFrequency: AudioKit.AKParameter = 10) -> AudioKit.AKOperation
}
public func mixer(_ first: AudioKit.AKParameter, _ second: AudioKit.AKParameter, balance: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
extension AKComputedParameter {
  public func distort(pregain: AudioKit.AKParameter = 2.0, postgain: AudioKit.AKParameter = 0.5, positiveShapeParameter: AudioKit.AKParameter = 0.0, negativeShapeParameter: AudioKit.AKParameter = 0.0) -> AudioKit.AKOperation
}
extension AVAudioPCMBuffer {
  public struct Peak {
    public init()
    public static var min: Swift.Float
    public var time: Swift.Double
    public var framePosition: Swift.Int
    public var amplitude: Swift.Float
  }
  @discardableResult
  open func copy(from buffer: AVFoundation.AVAudioPCMBuffer, readOffset: AVFoundation.AVAudioFrameCount = 0, frames: AVFoundation.AVAudioFrameCount = 0) -> AVFoundation.AVAudioFrameCount
  open func copyFrom(startSample: AVFoundation.AVAudioFrameCount) -> AVFoundation.AVAudioPCMBuffer?
  open func copyTo(count: AVFoundation.AVAudioFrameCount) -> AVFoundation.AVAudioPCMBuffer?
  open func peakTime() -> Swift.Double
  open func peak() -> AVFoundation.AVAudioPCMBuffer.Peak?
  open func normalize() -> AVFoundation.AVAudioPCMBuffer?
  open func reverse() -> AVFoundation.AVAudioPCMBuffer?
  open func fade(inTime: Swift.Double, outTime: Swift.Double, inRampType: AudioKit.AKSettings.RampType = .exponential, outRampType: AudioKit.AKSettings.RampType = .exponential) -> AVFoundation.AVAudioPCMBuffer?
}
@objc open class AKChorus : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKChorusAudioUnit
  public var internalAU: AudioKit.AKChorus.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var depthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dryWetMixRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultDepth: AudioToolbox.AUValue
  public static var defaultFeedback: AudioToolbox.AUValue
  public static var defaultDryWetMix: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let depth: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  final public let dryWetMix: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = defaultFrequency, depth: AudioToolbox.AUValue = defaultDepth, feedback: AudioToolbox.AUValue = defaultFeedback, dryWetMix: AudioToolbox.AUValue = defaultDryWetMix)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKChorus
}
@objc open class AKPeakingParametricEqualizerFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPeakingParametricEqualizerFilterAudioUnit
  public var internalAU: AudioKit.AKPeakingParametricEqualizerFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var gainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var qRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultGain: AudioToolbox.AUValue
  public static var defaultQ: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let gain: AudioKit.AKNodeParameter
  final public let q: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, gain: AudioToolbox.AUValue = defaultGain, q: AudioToolbox.AUValue = defaultQ)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPeakingParametricEqualizerFilter
}
extension AKComputedParameter {
  public func resonantFilter(frequency: AudioKit.AKParameter = 4_000.0, bandwidth: AudioKit.AKParameter = 1_000.0) -> AudioKit.AKOperation
}
public var callbackUgen: AudioKit.AKCustomUgen
@objc public class AKMetronome : AudioKit.AKOperationGenerator {
  public var tempo: Swift.Double {
    get
    set(value)
  }
  public var subdivision: Swift.Int {
    get
    set(value)
  }
  public var frequency1: Swift.Double {
    get
    set(value)
  }
  public var frequency2: Swift.Double {
    get
    set(value)
  }
  public var currentBeat: Swift.Int {
    get
    set(newValue)
  }
  public var callback: AudioKit.AKCallback {
    get
    set(value)
  }
  @objc public init(tempo: Swift.Double = 60)
  public func reset()
  @objc deinit
  @objc override public init(sporth: Swift.String = super, customUgens: [AudioKit.AKCustomUgen] = super)
}
extension AKAudioFile {
  public var sampler: AudioKit.AKAppleSampler? {
    get
  }
  public var midiSampler: AudioKit.AKMIDISampler? {
    get
  }
  public var player: AudioKit.AKPlayer {
    get
  }
}
@objc open class AKReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, dryWetMix: AudioToolbox.AUValue = 0.5)
  open func loadFactoryPreset(_ preset: AVFoundation.AVAudioUnitReverbPreset)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKTanhDistortion : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKTanhDistortionAudioUnit
  public var internalAU: AudioKit.AKTanhDistortion.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var pregainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var postgainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var positiveShapeParameterRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var negativeShapeParameterRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultPregain: AudioToolbox.AUValue
  public static var defaultPostgain: AudioToolbox.AUValue
  public static var defaultPositiveShapeParameter: AudioToolbox.AUValue
  public static var defaultNegativeShapeParameter: AudioToolbox.AUValue
  final public let pregain: AudioKit.AKNodeParameter
  final public let postgain: AudioKit.AKNodeParameter
  final public let positiveShapeParameter: AudioKit.AKNodeParameter
  final public let negativeShapeParameter: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, pregain: AudioToolbox.AUValue = defaultPregain, postgain: AudioToolbox.AUValue = defaultPostgain, positiveShapeParameter: AudioToolbox.AUValue = defaultPositiveShapeParameter, negativeShapeParameter: AudioToolbox.AUValue = defaultNegativeShapeParameter)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKTanhDistortion
}
@objc @_inheritsConvenienceInitializers public class AKDripAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public protocol AKMIDISystemRealTimeObserver {
  func startSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
  func stopSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
  func continueSRT(listener: AudioKit.AKMIDISystemRealTimeListener)
}
extension AKMIDISystemRealTimeObserver {
  public func isEqualTo(_ listener: AudioKit.AKMIDISystemRealTimeObserver) -> Swift.Bool
}
@objc @available(*, deprecated, message: "Transition to using AKPlayer instead. This class will be removed in a future release.")
open class AKAudioPlayer : AudioKit.AKNode, AudioKit.AKToggleable {
  @objc dynamic open var audioFileBuffer: AVFoundation.AVAudioPCMBuffer? {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic open var completionHandler: AudioKit.AKCallback?
  @objc dynamic open var looping: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic open var reversed: Swift.Bool {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var fadeInTime: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var fadeOutTime: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var audioFile: AudioKit.AKAudioFile {
    @objc get
  }
  @objc dynamic open var path: Swift.String {
    @objc get
  }
  @objc dynamic open var duration: Swift.Double {
    @objc get
  }
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open var currentTime: Swift.Double {
    @objc get
  }
  @objc dynamic open var playhead: Swift.Double {
    @objc get
  }
  @objc dynamic open var pan: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var startTime: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic open var endTime: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic open var scheduledTime: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var scheduledAVTime: AVFoundation.AVAudioTime?
  @objc public init(file: AudioKit.AKAudioFile, looping: Swift.Bool = false, lazyBuffering: Swift.Bool = false, completionHandler: AudioKit.AKCallback? = nil) throws
  @objc open func start()
  open func play(at when: AVFoundation.AVAudioTime?)
  @objc open func stop()
  open func pause()
  open func resume()
  open func reloadFile() throws
  @objc open func replace(file: AudioKit.AKAudioFile) throws
  open func play()
  @objc open func play(from startTime: Swift.Double)
  @objc open func play(from startTime: Swift.Double, to endTime: Swift.Double)
  open func play(from startTime: Swift.Double, to endTime: Swift.Double, when scheduledTime: Swift.Double)
  open func play(from startTime: Swift.Double, to endTime: Swift.Double, avTime: AVFoundation.AVAudioTime?)
  open func schedule(from startTime: Swift.Double, to endTime: Swift.Double, avTime: AVFoundation.AVAudioTime?)
  open func getPeakTime() -> Swift.Double
  open class func secondsToAVAudioTime(hostTime: Swift.UInt64, time: Swift.Double) -> AVFoundation.AVAudioTime
  @objc open func stopAtNextLoopEnd()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
extension AKMoogLadder {
  public func presetFogMoogLadder()
  public func presetDullNoiseMoogLadder()
  public func printCurrentValuesAsPreset()
}
@objc @_inheritsConvenienceInitializers public class AKKorgLowPassFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKTuningTable {
  @objc dynamic public func presetHighlandBagPipes() -> Swift.Int
  @objc dynamic public func presetDiaphonicTetrachord() -> Swift.Int
}
extension AKOperation {
  public func times(_ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
  public func scaledBy(_ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
}
public func * (left: AudioKit.AKParameter, right: AudioKit.AKParameter) -> AudioKit.AKOperation
public func * (left: AudioKit.AKStereoOperation, right: AudioKit.AKParameter) -> AudioKit.AKStereoOperation
public func * (left: AudioKit.AKParameter, right: AudioKit.AKStereoOperation) -> AudioKit.AKStereoOperation
@objc @_inheritsConvenienceInitializers public class AKAutoPannerAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKFlatFrequencyResponseReverbAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
infix operator ~== : ComparisonPrecedence
public func ~== (left: Swift.Double, right: Swift.Double) -> Swift.Bool
infix operator ~!= : ComparisonPrecedence
public func ~!= (left: Swift.Double, right: Swift.Double) -> Swift.Bool
infix operator ~<= : ComparisonPrecedence
public func ~<= (left: Swift.Double, right: Swift.Double) -> Swift.Bool
infix operator ~>= : ComparisonPrecedence
public func ~>= (left: Swift.Double, right: Swift.Double) -> Swift.Bool
infix operator ~< : ComparisonPrecedence
public func ~< (left: Swift.Double, right: Swift.Double) -> Swift.Bool
infix operator ~> : ComparisonPrecedence
public func ~> (left: Swift.Double, right: Swift.Double) -> Swift.Bool
@objc @_inheritsConvenienceInitializers public class AKPhaserAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKManager {
  @objc public static func connect(_ sourceNode: AVFoundation.AVAudioNode, to destNodes: [AVFoundation.AVAudioConnectionPoint], fromBus sourceBus: AVFoundation.AVAudioNodeBus, format: AVFoundation.AVAudioFormat?)
  @objc public static func connect(_ node1: AVFoundation.AVAudioNode, to node2: AVFoundation.AVAudioNode, fromBus bus1: AVFoundation.AVAudioNodeBus, toBus bus2: AVFoundation.AVAudioNodeBus, format: AVFoundation.AVAudioFormat?)
  @objc public static func connect(_ node1: AVFoundation.AVAudioNode, to node2: AVFoundation.AVAudioNode, format: AVFoundation.AVAudioFormat?)
  @objc public static func detach(nodes: [AVFoundation.AVAudioNode])
  @available(iOS 11, OSX 10.13, tvOS 11, *)
  @objc public static func renderToFile(_ audioFile: AVFoundation.AVAudioFile, duration: Swift.Double, prerender: (() -> Swift.Void)? = nil, progress: ((Swift.Double) -> Swift.Void)? = nil) throws
  @available(iOS 11, OSX 10.13, tvOS 11, *)
  public static func printConnections()
}
extension AKComputedParameter {
  public func variableDelay(time: AudioKit.AKParameter = 1.0, feedback: AudioKit.AKParameter = 0.0, maximumDelayTime: Swift.Double = 5.0) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func whiteNoise(amplitude: AudioKit.AKParameter = 1.0) -> AudioKit.AKOperation
}
@objc open class AKBitCrusher : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKBitCrusherAudioUnit
  public var internalAU: AudioKit.AKBitCrusher.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var bitDepthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var sampleRateRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultBitDepth: AudioToolbox.AUValue
  public static var defaultSampleRate: AudioToolbox.AUValue
  final public let bitDepth: AudioKit.AKNodeParameter
  final public let sampleRate: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, bitDepth: AudioToolbox.AUValue = defaultBitDepth, sampleRate: AudioToolbox.AUValue = defaultSampleRate)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBitCrusher
}
public protocol Numeric : AudioKit.AKParameter {
  func value() -> Swift.Double
}
extension Int : AudioKit.Numeric {
  public func value() -> Swift.Double
}
extension Float : AudioKit.Numeric {
  public func value() -> Swift.Double
}
extension Double : AudioKit.Numeric {
  public func value() -> Swift.Double
}
public func + (lhs: AudioKit.Numeric, rhs: AudioKit.Numeric) -> Swift.Double
public func - (lhs: AudioKit.Numeric, rhs: AudioKit.Numeric) -> Swift.Double
public func / (lhs: AudioKit.Numeric, rhs: AudioKit.Numeric) -> Swift.Double
public func * (lhs: AudioKit.Numeric, rhs: AudioKit.Numeric) -> Swift.Double
extension MIDIPacketList : Swift.Sequence {
  public typealias Element = CoreMIDI.MIDIPacket
  public var count: Swift.UInt32 {
    get
  }
  public func makeIterator() -> Swift.AnyIterator<CoreMIDI.MIDIPacketList.Element>
  public typealias Iterator = Swift.AnyIterator<CoreMIDI.MIDIPacketList.Element>
}
@objc open class AKAutoWah : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKAutoWahAudioUnit
  public var internalAU: AudioKit.AKAutoWah.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var wahRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var mixRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultWah: AudioToolbox.AUValue
  public static var defaultMix: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let wah: AudioKit.AKNodeParameter
  final public let mix: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, wah: AudioToolbox.AUValue = defaultWah, mix: AudioToolbox.AUValue = defaultMix, amplitude: AudioToolbox.AUValue = defaultAmplitude)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKAutoWah
}
@objc open class AKMixer : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pan: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc public init(volume: AudioToolbox.AUValue = 1.0)
  public convenience init(_ inputs: AudioKit.AKNode?...)
  @objc public convenience init(_ inputs: [AudioKit.AKNode])
  @objc open func start()
  @objc open func stop()
  @objc open func connect(input: AudioKit.AKNode?, bus: Swift.Int)
  @objc open func connect(input: AudioKit.AKNode?)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AKSynthAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  public func playNote(noteNumber: Swift.UInt8, velocity: Swift.UInt8, noteFrequency: Swift.Float)
  public func stopNote(noteNumber: Swift.UInt8, immediate: Swift.Bool)
  public func sustainPedal(down: Swift.Bool)
  @objc deinit
}
@objc open class AKTremolo : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKTremoloAudioUnit
  public var internalAU: AudioKit.AKTremolo.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var depthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultDepth: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let depth: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = defaultFrequency, depth: AudioToolbox.AUValue = defaultDepth, waveform: AudioKit.AKTable = AKTable(.positiveSine))
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKTremolo
}
@objc open class AKStringResonator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKStringResonatorAudioUnit
  public var internalAU: AudioKit.AKStringResonator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var fundamentalFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFundamentalFrequency: AudioToolbox.AUValue
  public static var defaultFeedback: AudioToolbox.AUValue
  final public let fundamentalFrequency: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, fundamentalFrequency: AudioToolbox.AUValue = defaultFundamentalFrequency, feedback: AudioToolbox.AUValue = defaultFeedback)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKStringResonator
}
extension AVAudioCommonFormat : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc extension AVAudioFile {
  @objc dynamic open var samplesCount: AudioKit.Sample {
    @objc get
  }
  @objc dynamic open var sampleRate: Swift.Double {
    @objc get
  }
  @objc dynamic open var channelCount: Swift.UInt32 {
    @objc get
  }
  @objc dynamic open var duration: Swift.Double {
    @objc get
  }
  @objc dynamic open var interleaved: Swift.Bool {
    @objc get
  }
  @objc dynamic open var standard: Swift.Bool {
    @objc get
  }
  @objc dynamic open var commonFormatString: Swift.String {
    @objc get
  }
  @objc dynamic open var directoryPath: Foundation.URL {
    @objc get
  }
  @objc dynamic open var fileNamePlusExtension: Swift.String {
    @objc get
  }
  @objc dynamic open var fileName: Swift.String {
    @objc get
  }
  @objc dynamic open var fileExt: Swift.String {
    @objc get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc dynamic public var mimeType: Swift.String? {
    @objc get
  }
  @objc public static func cleanTempDirectory()
}
@objc open class AKAudioFile : AVFoundation.AVAudioFile {
  public enum BaseDirectory {
    case temp
    case documents
    case resources
    case custom
    public static func == (a: AudioKit.AKAudioFile.BaseDirectory, b: AudioKit.AKAudioFile.BaseDirectory) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  open var avAsset: AVFoundation.AVURLAsset {
    get
  }
  open var currentExportSession: AVFoundation.AVAssetExportSession?
  public typealias FloatChannelData = [[Swift.Float]]
  open var floatChannelData: AudioKit.AKAudioFile.FloatChannelData? {
    get
    set(value)
  }
  open var pcmBuffer: AVFoundation.AVAudioPCMBuffer? {
    get
    set(value)
  }
  open var maxLevel: Swift.Float {
    get
    set(value)
  }
  @objc override dynamic public init(forReading fileURL: Foundation.URL) throws
  @objc override dynamic public init(forReading fileURL: Foundation.URL, commonFormat format: AVFoundation.AVAudioCommonFormat, interleaved: Swift.Bool) throws
  @objc override dynamic public init(forWriting fileURL: Foundation.URL, settings: [Swift.String : Any], commonFormat format: AVFoundation.AVAudioCommonFormat, interleaved: Swift.Bool) throws
  @objc override dynamic public init(forWriting fileURL: Foundation.URL, settings: [Swift.String : Any]) throws
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKPhaseDistortionOscillatorBank : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKPhaseDistortionOscillatorBankAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKPhaseDistortionOscillatorBank.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var phaseDistortion: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), phaseDistortion: AudioToolbox.AUValue = 0.0, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPhaseDistortionOscillatorBank
}
@objc open class AKMorphingOscillator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKMorphingOscillatorAudioUnit
  public var internalAU: AudioKit.AKMorphingOscillator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var indexRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningOffsetRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultIndex: AudioToolbox.AUValue
  public static var defaultDetuningOffset: AudioToolbox.AUValue
  public static var defaultDetuningMultiplier: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  final public let index: AudioKit.AKNodeParameter
  final public let detuningOffset: AudioKit.AKNodeParameter
  final public let detuningMultiplier: AudioKit.AKNodeParameter
  public init(waveformArray: [AudioKit.AKTable] = [AKTable(.triangle), AKTable(.square), AKTable(.sine), AKTable(.sawtooth)], frequency: AudioToolbox.AUValue = defaultFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude, index: AudioToolbox.AUValue = defaultIndex, detuningOffset: AudioToolbox.AUValue = defaultDetuningOffset, detuningMultiplier: AudioToolbox.AUValue = defaultDetuningMultiplier)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKMorphingOscillator
}
@objc open class AKMIDIOMNIListener : ObjectiveC.NSObject {
  @objc public init(omni: Swift.Bool = true)
  @objc deinit
  @objc override dynamic public init()
}
extension AKMIDIOMNIListener : AudioKit.AKMIDIListener {
  public func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc dynamic public func omniStateChange()
}
@objc open class AKResonantFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKResonantFilterAudioUnit
  public var internalAU: AudioKit.AKResonantFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var bandwidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultBandwidth: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let bandwidth: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = defaultFrequency, bandwidth: AudioToolbox.AUValue = defaultBandwidth)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKResonantFilter
}
@objc open class AKToneFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKToneFilterAudioUnit
  public var internalAU: AudioKit.AKToneFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var halfPowerPointRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultHalfPowerPoint: AudioToolbox.AUValue
  final public let halfPowerPoint: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, halfPowerPoint: AudioToolbox.AUValue = defaultHalfPowerPoint)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKToneFilter
}
@objc public protocol AKTiming {
  @objc func start(at audioTime: AVFoundation.AVAudioTime?)
  @objc func stop()
  @objc var isStarted: Swift.Bool { get }
  @objc func setPosition(_ position: Swift.Double)
  @objc(positionAtAudioTime:) func position(at audioTime: AVFoundation.AVAudioTime?) -> Swift.Double
  @objc(audioTimeAtPosition:) func audioTime(at position: Swift.Double) -> AVFoundation.AVAudioTime?
  @objc optional func prepare()
}
extension AKTiming {
  public static func syncStart(_ nodes: [AudioKit.AKTiming], at position: Swift.Double = 0) -> AVFoundation.AVAudioTime
  public func synchronizeWith(other: AudioKit.AKTiming, at audioTime: AVFoundation.AVAudioTime? = nil)
}
@objc open class AKNodeTiming : ObjectiveC.NSObject {
  weak open var node: AudioKit.AKOutput?
  open var currentTime: Swift.Double {
    get
    set(newValue)
  }
  open func start()
  @objc open func stop()
  public init(node: AudioKit.AKOutput)
  @objc deinit
  @objc override dynamic public init()
}
extension AKNodeTiming : AudioKit.AKTiming {
  @objc dynamic public var isStarted: Swift.Bool {
    @objc get
  }
  public var isNotStarted: Swift.Bool {
    get
  }
  @objc dynamic open func position(at audioTime: AVFoundation.AVAudioTime?) -> Swift.Double
  @objc dynamic open func audioTime(at position: Swift.Double) -> AVFoundation.AVAudioTime?
  @objc dynamic open func start(at audioTime: AVFoundation.AVAudioTime?)
  @objc dynamic open func setPosition(_ position: Swift.Double)
}
public struct MIDIFileTrackChunk {
  public var chunkEvents: [AudioKit.AKMIDIFileChunkEvent] {
    get
  }
}
extension AKAudioUnitManager {
  public static var internalAudioUnits: [Swift.String] {
    get
  }
  public static func effectComponents(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public static func instrumentComponents(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public static func midiProcessorComponents(completionHandler: AudioKit.AKAudioUnitManager.AKComponentListCallback? = nil)
  public static func createEffectAudioUnit(_ componentDescription: AudioToolbox.AudioComponentDescription, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKEffectCallback)
  public static func createInstrumentAudioUnit(_ componentDescription: AudioToolbox.AudioComponentDescription, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKInstrumentCallback)
  public static func createMIDIProcessorAudioUnit(_ componentDescription: AudioToolbox.AudioComponentDescription, completionHandler: @escaping AudioKit.AKAudioUnitManager.AKMIDIProcessorCallback)
  public static func canLoadInProcess(componentDescription: AudioToolbox.AudioComponentDescription) -> Swift.Bool
  public static func createInternalEffect(name: Swift.String) -> AVFoundation.AVAudioUnit?
}
extension AKFMOscillator {
  public func presetStunRay()
  public func presetFogHorn()
  public func presetBuzzer()
  public func presetSpiral()
  public func presetWobble()
}
@objc @_inheritsConvenienceInitializers public class AKMoogLadderAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKComputedParameter {
  public func lowPassButterworthFilter(cutoffFrequency: AudioKit.AKParameter = 1_000) -> AudioKit.AKOperation
}
@objc open class AKMoogLadder : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKMoogLadderAudioUnit
  public var internalAU: AudioKit.AKMoogLadder.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var resonanceRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  public static var defaultResonance: AudioToolbox.AUValue
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  final public let resonance: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency, resonance: AudioToolbox.AUValue = defaultResonance)
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  @objc deinit
  public typealias _Self = AudioKit.AKMoogLadder
}
public typealias DeviceID = CoreAudio.AudioDeviceID
@objc open class AKDevice : ObjectiveC.NSObject {
  open var name: Swift.String
  open var nInputChannels: Swift.Int?
  open var nOutputChannels: Swift.Int?
  open var deviceID: AudioKit.DeviceID {
    get
  }
  public init(name: Swift.String, deviceID: AudioKit.DeviceID, dataSource: Swift.String = "")
  public convenience init(ezAudioDevice: AudioKit.EZAudioDevice)
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKPluckedString : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPluckedStringAudioUnit
  public var internalAU: AudioKit.AKPluckedString.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultLowestFrequency: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  public init(frequency: AudioToolbox.AUValue = defaultFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude, lowestFrequency: AudioToolbox.AUValue = defaultLowestFrequency)
  open func trigger()
  open func trigger(frequency: AudioToolbox.AUValue, amplitude: AudioToolbox.AUValue = 1)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPluckedString
}
public protocol AKParameter : Swift.CustomStringConvertible {
  func toMono() -> AudioKit.AKOperation
  func toStereo() -> AudioKit.AKStereoOperation
}
extension AKParameter {
  public func toMono() -> AudioKit.AKOperation
  public func toStereo() -> AudioKit.AKStereoOperation
}
extension AKAudioFile {
  public func normalized(baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = UUID().uuidString, newMaxLevel: Swift.Float = 0.0) throws -> AudioKit.AKAudioFile
  public func reversed(baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = UUID().uuidString) throws -> AudioKit.AKAudioFile
  public func appendedBy(file: AudioKit.AKAudioFile, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = UUID().uuidString) throws -> AudioKit.AKAudioFile?
  public func extracted(fromSample: Swift.Int64 = 0, toSample: Swift.Int64 = 0, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = UUID().uuidString) throws -> AudioKit.AKAudioFile
}
extension AKDelay {
  public func presetShortDelay()
  public func presetDenseLongDelay()
  public func presetElectricCircuitsDelay()
  public func printCurrentValuesAsPreset()
}
extension AKComputedParameter {
  public func reverberateWithCombFilter(reverbDuration: AudioKit.AKParameter = 1.0, loopDuration: AudioKit.AKParameter = 0.1) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func fmOscillator(baseFrequency: AudioKit.AKParameter = 440, carrierMultiplier: AudioKit.AKParameter = 1.0, modulatingMultiplier: AudioKit.AKParameter = 1.0, modulationIndex: AudioKit.AKParameter = 1.0, amplitude: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
@objc open class AKDCBlock : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKDCBlockAudioUnit
  public var internalAU: AudioKit.AKDCBlock.AKAudioUnitType? {
    get
  }
  public init(_ input: AudioKit.AKNode? = nil)
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  @objc deinit
  public typealias _Self = AudioKit.AKDCBlock
}
@objc open class AKToneComplementFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKToneComplementFilterAudioUnit
  public var internalAU: AudioKit.AKToneComplementFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var halfPowerPointRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultHalfPowerPoint: AudioToolbox.AUValue
  final public let halfPowerPoint: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, halfPowerPoint: AudioToolbox.AUValue = defaultHalfPowerPoint)
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  @objc deinit
  public typealias _Self = AudioKit.AKToneComplementFilter
}
@objc open class AKMIDISampler : AudioKit.AKAppleSampler {
  open var midiIn: CoreMIDI.MIDIEndpointRef
  open var name: Swift.String
  public init(name midiOutputName: Swift.String)
  open func enableMIDI(_ midiClient: CoreMIDI.MIDIClientRef = AKManager.midi.client, name: Swift.String = "MIDI Sampler")
  open func receivedMIDINoteOn(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel) throws
  open func midiCC(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel) throws
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber, channel: AudioKit.MIDIChannel) throws
  open func destroyEndpoint()
  @objc deinit
  override public init(file: Swift.String? = super)
}
extension AKOperation {
  public func count(maximum: AudioKit.AKParameter = 1_000_000, looping: Swift.Bool = true) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKMorphingOscillatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKMorphingOscillatorFilterSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKMorphingOscillatorFilterSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKMorphingOscillatorFilterSynth.AKAudioUnitType? {
    get
  }
  @objc open var waveformArray: [AudioKit.AKTable] {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var index: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterCutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterEnvelopeStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFODepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFORate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveformArray: [AudioKit.AKTable] = [AKTable(.triangle), AKTable(.square), AKTable(.sine), AKTable(.sawtooth)], index: AudioToolbox.AUValue = 0, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0, filterCutoffFrequency: AudioToolbox.AUValue = 22_050.0, filterResonance: AudioToolbox.AUValue = 0.0, filterAttackDuration: AudioToolbox.AUValue = 0.1, filterDecayDuration: AudioToolbox.AUValue = 0.1, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 1.0, filterEnvelopeStrength: AudioToolbox.AUValue = 0.0, filterLFODepth: AudioToolbox.AUValue = 0.0, filterLFORate: AudioToolbox.AUValue = 0.0)
  open func reset()
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKMorphingOscillatorFilterSynth
}
public typealias MIDIByte = Swift.UInt8
public typealias MIDIWord = Swift.UInt16
public typealias MIDINoteNumber = Swift.UInt8
public typealias MIDIVelocity = Swift.UInt8
public typealias MIDIChannel = Swift.UInt8
public typealias Sample = Swift.UInt32
public typealias AKCCallback = @convention(block) () -> Swift.Void
public typealias AKCMIDICallback = @convention(block) (Swift.UInt8, Swift.UInt8, Swift.UInt8) -> Swift.Void
extension AudioUnitParameterOptions {
  public static var `default`: AudioToolbox.AudioUnitParameterOptions
}
extension CGRect {
  public init(size: CoreGraphics.CGSize)
  public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  public init(width: Swift.Int, height: Swift.Int)
}
public func fourCC(_ string: Swift.String) -> Swift.UInt32
public func random(in range: Swift.ClosedRange<AudioToolbox.AUValue>) -> AudioToolbox.AUValue
extension Float {
  public func normalized(from range: Swift.ClosedRange<AudioToolbox.AUValue>, taper: AudioToolbox.AUValue = 1) -> AudioToolbox.AUValue
  public func denormalized(to range: Swift.ClosedRange<AudioToolbox.AUValue>, taper: AudioToolbox.AUValue = 1) -> AudioToolbox.AUValue
}
extension Int {
  public func midiNoteToFrequency(_ aRef: AudioToolbox.AUValue = 440.0) -> AudioToolbox.AUValue
}
extension UInt8 {
  public func midiNoteToFrequency(_ aRef: AudioToolbox.AUValue = 440.0) -> AudioToolbox.AUValue
}
extension Float {
  public func midiNoteToFrequency(_ aRef: AudioToolbox.AUValue = 440.0) -> AudioToolbox.AUValue
}
extension Int {
  public func frequencyToMIDINote(_ aRef: AudioToolbox.AUValue = 440.0) -> AudioToolbox.AUValue
}
extension Float {
  public func frequencyToMIDINote(_ aRef: AudioToolbox.AUValue = 440.0) -> AudioToolbox.AUValue
}
extension RangeReplaceableCollection where Self.Element : Swift.ExpressibleByIntegerLiteral {
  public init(zeros count: Swift.Int)
}
extension ClosedRange {
  public func clamp(_ value: Bound) -> Bound
}
extension AVAudioUnit {
  public class func _instantiate(with component: AudioToolbox.AudioComponentDescription, callback: @escaping (AVFoundation.AVAudioUnit) -> Swift.Void)
}
extension AUParameter {
  @nonobjc public convenience init(identifier: Swift.String, name: Swift.String, address: AudioToolbox.AUParameterAddress, range: Swift.ClosedRange<AudioToolbox.AUValue>, unit: AudioToolbox.AudioUnitParameterUnit, flags: AudioToolbox.AudioUnitParameterOptions)
}
public protocol Occupiable {
  var isEmpty: Swift.Bool { get }
  var isNotEmpty: Swift.Bool { get }
}
extension Occupiable {
  public var isNotEmpty: Swift.Bool {
    get
  }
}
extension String : AudioKit.Occupiable {
}
extension Array : AudioKit.Occupiable {
}
extension Dictionary : AudioKit.Occupiable {
}
extension Set : AudioKit.Occupiable {
}
prefix operator ❗️
prefix public func ❗️ (a: Swift.Bool) -> Swift.Bool
@objc open class AKHighPassFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var cutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var resonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = 6_900, resonance: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  @objc deinit
  public typealias _Self = AudioKit.AKHighPassFilter
}
@objc open class AKOscillatorFilterSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKOscillatorFilterSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKOscillatorFilterSynth.AKAudioUnitType? {
    get
  }
  @objc open var waveform: AudioKit.AKTable? {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterCutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterEnvelopeStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFODepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFORate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0, filterCutoffFrequency: AudioToolbox.AUValue = 22_050.0, filterResonance: AudioToolbox.AUValue = 0.0, filterAttackDuration: AudioToolbox.AUValue = 0.1, filterDecayDuration: AudioToolbox.AUValue = 0.1, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 1.0, filterEnvelopeStrength: AudioToolbox.AUValue = 0.0, filterLFODepth: AudioToolbox.AUValue = 0.0, filterLFORate: AudioToolbox.AUValue = 0.0)
  open func reset()
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKOscillatorFilterSynth
}
extension AKComputedParameter {
  public func clip(_ limit: AudioKit.AKParameter = 1.0) -> AudioKit.AKOperation
}
public struct AKMIDIStatus : AudioKit.AKMIDIMessage {
  public var data: [Swift.UInt8] {
    get
  }
  public var byte: AudioKit.MIDIByte
  public init(type: AudioKit.AKMIDIStatusType, channel: AudioKit.MIDIChannel)
  public init(command: AudioKit.AKMIDISystemCommand)
  public init?(byte: AudioKit.MIDIByte)
  public var type: AudioKit.AKMIDIStatusType? {
    get
  }
  public var channel: AudioKit.MIDIChannel {
    get
  }
  public var description: Swift.String {
    get
  }
  public var length: Swift.Int {
    get
  }
}
public enum AKMIDIStatusType : Swift.Int {
  case noteOff
  case noteOn
  case polyphonicAftertouch
  case controllerChange
  case programChange
  case channelAftertouch
  case pitchWheel
  public static func from(byte: AudioKit.MIDIByte) -> AudioKit.AKMIDIStatusType?
  public var length: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc open class AKDecimator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var decimation: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rounding: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var mix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, decimation: AudioToolbox.AUValue = 0.5, rounding: AudioToolbox.AUValue = 0, mix: AudioToolbox.AUValue = 1)
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDecimator
}
@objc open class AKNode : ObjectiveC.NSObject {
  open var avAudioNode: AVFoundation.AVAudioNode
  open var avAudioUnit: AVFoundation.AVAudioUnit?
  open var avAudioUnitOrNode: AVFoundation.AVAudioNode {
    get
  }
  public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = false)
  public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = false)
  @objc deinit
  open func detach()
  @objc override dynamic public init()
}
open class AKNodeParameter {
  public var identifier: Swift.String {
    get
  }
  public var value: AudioToolbox.AUValue {
    get
    set(value)
  }
  public var boolValue: Swift.Bool {
    get
    set(newValue)
  }
  public var minValue: AudioToolbox.AUValue {
    get
  }
  public var maxValue: AudioToolbox.AUValue {
    get
  }
  public var range: Swift.ClosedRange<AudioToolbox.AUValue> {
    get
  }
  public var rampDuration: Swift.Float {
    get
    set(value)
  }
  public var rampTaper: Swift.Float {
    get
    set(value)
  }
  public var rampSkew: Swift.Float {
    get
    set(value)
  }
  public init(identifier: Swift.String, value: AudioToolbox.AUValue = 0)
  public func associate(with au: AudioKit.AKAudioUnitBase?, value: AudioToolbox.AUValue? = nil)
  public func associate(with au: AudioKit.AKAudioUnitBase?, value: Swift.Bool)
  public func beginTouch(value: AudioToolbox.AUValue? = nil)
  public func endTouch(value: AudioToolbox.AUValue? = nil)
  @objc deinit
}
extension AKNode : AudioKit.AKOutput {
  @objc dynamic public var outputNode: AVFoundation.AVAudioNode {
    @objc get
  }
}
public protocol AKPolyphonic {
  func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel)
  func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel)
  func stop(noteNumber: AudioKit.MIDINoteNumber)
}
@_inheritsConvenienceInitializers @objc open class AKPolyphonicNode : AudioKit.AKNode, AudioKit.AKPolyphonic {
  @objc public static var tuningTable: AudioKit.AKTuningTable
  @objc open var midiInstrument: AVFoundation.AVAudioUnitMIDIInstrument?
  @objc open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0)
  @objc open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
public protocol AKToggleable {
  var isStarted: Swift.Bool { get }
  func start()
  func stop()
}
extension AKToggleable {
  public var isPlaying: Swift.Bool {
    get
  }
  public var isStopped: Swift.Bool {
    get
  }
  public var isBypassed: Swift.Bool {
    get
  }
  public func play()
  public func bypass()
}
extension AKToggleable where Self : AudioKit.AKComponent {
  public var isStarted: Swift.Bool {
    get
  }
  public func start()
  public func stop()
}
@objc open class AKZitaReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKZitaReverbAudioUnit
  public var internalAU: AudioKit.AKZitaReverb.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var predelayRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var crossoverFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var lowReleaseTimeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var midReleaseTimeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dampingFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var equalizerFrequency1Range: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var equalizerLevel1Range: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var equalizerFrequency2Range: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var equalizerLevel2Range: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dryWetMixRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultPredelay: AudioToolbox.AUValue
  public static var defaultCrossoverFrequency: AudioToolbox.AUValue
  public static var defaultLowReleaseTime: AudioToolbox.AUValue
  public static var defaultMidReleaseTime: AudioToolbox.AUValue
  public static var defaultDampingFrequency: AudioToolbox.AUValue
  public static var defaultEqualizerFrequency1: AudioToolbox.AUValue
  public static var defaultEqualizerLevel1: AudioToolbox.AUValue
  public static var defaultEqualizerFrequency2: AudioToolbox.AUValue
  public static var defaultEqualizerLevel2: AudioToolbox.AUValue
  public static var defaultDryWetMix: AudioToolbox.AUValue
  final public let predelay: AudioKit.AKNodeParameter
  final public let crossoverFrequency: AudioKit.AKNodeParameter
  final public let lowReleaseTime: AudioKit.AKNodeParameter
  final public let midReleaseTime: AudioKit.AKNodeParameter
  final public let dampingFrequency: AudioKit.AKNodeParameter
  final public let equalizerFrequency1: AudioKit.AKNodeParameter
  final public let equalizerLevel1: AudioKit.AKNodeParameter
  final public let equalizerFrequency2: AudioKit.AKNodeParameter
  final public let equalizerLevel2: AudioKit.AKNodeParameter
  final public let dryWetMix: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, predelay: AudioToolbox.AUValue = defaultPredelay, crossoverFrequency: AudioToolbox.AUValue = defaultCrossoverFrequency, lowReleaseTime: AudioToolbox.AUValue = defaultLowReleaseTime, midReleaseTime: AudioToolbox.AUValue = defaultMidReleaseTime, dampingFrequency: AudioToolbox.AUValue = defaultDampingFrequency, equalizerFrequency1: AudioToolbox.AUValue = defaultEqualizerFrequency1, equalizerLevel1: AudioToolbox.AUValue = defaultEqualizerLevel1, equalizerFrequency2: AudioToolbox.AUValue = defaultEqualizerFrequency2, equalizerLevel2: AudioToolbox.AUValue = defaultEqualizerLevel2, dryWetMix: AudioToolbox.AUValue = defaultDryWetMix)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKZitaReverb
}
@objc @_inheritsConvenienceInitializers public class AKClipperAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKComputedParameter {
  public func trackedAmplitude(_ trackedAmplitude: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
@objc open class AKFader : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public typealias AKAudioUnitType = AudioKit.AKFaderAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKFader.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var gainRange: (Swift.ClosedRange<AudioToolbox.AUValue>)
  open var gain: AudioToolbox.AUValue {
    get
    set(value)
  }
  final public let leftGain: AudioKit.AKNodeParameter
  final public let rightGain: AudioKit.AKNodeParameter
  public var dB: AudioToolbox.AUValue {
    get
    set(newValue)
  }
  final public let flipStereo: AudioKit.AKNodeParameter
  final public let mixToMono: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, gain: AudioToolbox.AUValue = 1)
  @objc deinit
  override open func detach()
  public func addAutomationPoint(value: AudioToolbox.AUValue, at startTime: Swift.Double, rampDuration: Swift.Double = 0, taper taperValue: Swift.Float = 1, skew skewValue: Swift.Float = 0)
  public func clearAutomationPoints()
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFader
}
@objc open class AKBalancer : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public typealias AKAudioUnitType = AudioKit.AKBalancerAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKBalancer.AKAudioUnitType? {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, comparator: AudioKit.AKNode)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBalancer
}
extension AKOperation {
  public static func squareWave(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 1.0, pulseWidth: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers open class AKSynthKick : AudioKit.AKMIDIInstrument {
  @objc override public init(midiInputName: Swift.String? = nil)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
}
@objc open class AKSynthSnare : AudioKit.AKMIDIInstrument {
  @objc public init(duration: Swift.Double = 0.143, resonance: Swift.Double = 0.9)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(midiInputName: Swift.String? = super)
}
extension AKCostelloReverb {
  public func presetShortTailCostelloReverb()
  public func presetLowRingingLongTailCostelloReverb()
  public func printCurrentValuesAsPreset()
}
extension AKComputedParameter {
  public func smoothDelay(time: AudioKit.AKParameter = 1.0, feedback: AudioKit.AKParameter = 0.0, samples: Swift.Int = 1_024, maximumDelayTime: Swift.Double = 5.0) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func brownianNoise(amplitude: AudioKit.AKParameter = 1.0) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKPhaseLockedVocoderAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKFlangerAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKStereoInput : AudioKit.AKNode, AudioKit.AKToggleable {
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  public init(volume: AudioToolbox.AUValue = 0.0)
  @objc deinit
  @objc open func start()
  @objc open func stop()
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
public protocol ObserverProtocol {
  func isEqualTo(_ listener: AudioKit.ObserverProtocol) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class AKVariableDelayAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public struct AKTimeSignature : Swift.CustomStringConvertible, Swift.Equatable {
  public enum TimeSignatureBottomValue : Swift.UInt8 {
    case two
    case four
    case eight
    case sixteen
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var topValue: Swift.UInt8
  public var bottomValue: AudioKit.AKTimeSignature.TimeSignatureBottomValue
  public init(topValue: Swift.UInt8 = 4, bottomValue: AudioKit.AKTimeSignature.TimeSignatureBottomValue = .four)
  public var readableTimeSignature: (Swift.Int, Swift.Int) {
    get
  }
  public var description: Swift.String {
    get
  }
  public static func == (a: AudioKit.AKTimeSignature, b: AudioKit.AKTimeSignature) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class AKLowPassButterworthFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKStereoFieldLimiterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKOperation {
  public func increment(on trigger: AudioKit.AKParameter, by step: AudioKit.AKParameter = 1.0, minimum: AudioKit.AKParameter = 0.0, maximum: AudioKit.AKParameter = 1_000_000) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKEqualizerFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKWhiteNoiseAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKAudioUnitInstrument : AudioKit.AKMIDIInstrument {
  public init?(audioUnit: AVFoundation.AVAudioUnitMIDIInstrument)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity = 64, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIAftertouch(noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIAftertouch(_ pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIPitchWheel(_ pitchWheelValue: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc deinit
  override public init(midiInputName: Swift.String? = super)
}
@objc @_inheritsConvenienceInitializers public class AKRolandTB303FilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKToneComplementFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public struct AKMIDIFile {
  public var trackChunks: [AudioKit.MIDIFileTrackChunk] {
    get
  }
  public var tempoTrack: AudioKit.AKMIDIFileTrack? {
    get
  }
  public var tracks: [AudioKit.AKMIDIFileTrack] {
    get
  }
  public var format: Swift.Int {
    get
  }
  public var numberOfTracks: Swift.Int {
    get
  }
  public var timeFormat: AudioKit.MIDITimeFormat? {
    get
  }
  public var ticksPerBeat: Swift.Int? {
    get
  }
  public var framesPerSecond: Swift.Int? {
    get
  }
  public var ticksPerFrame: Swift.Int? {
    get
  }
  public var timeDivision: Swift.UInt16 {
    get
  }
  public init(url: Foundation.URL)
  public init(path: Swift.String)
}
@objc open class AKConverter : ObjectiveC.NSObject {
  public typealias AKConverterCallback = (Swift.Error?) -> Swift.Void
  public static var outputFormats: [Swift.String]
  public static var inputFormats: [Swift.String]
  public struct Options {
    public init()
    public var format: Swift.String?
    public var sampleRate: Swift.Double?
    public var bitDepth: Swift.UInt32?
    public var bitRate: Swift.UInt32 {
      get
      set(value)
    }
    public var channels: Swift.UInt32?
    public var isInterleaved: Swift.Bool?
    public var eraseFile: Swift.Bool
  }
  open var inputURL: Foundation.URL?
  open var outputURL: Foundation.URL?
  open var options: AudioKit.AKConverter.Options?
  public init(inputURL: Foundation.URL, outputURL: Foundation.URL, options: AudioKit.AKConverter.Options? = nil)
  @objc deinit
  open func start(completionHandler: AudioKit.AKConverter.AKConverterCallback? = nil)
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class AKTanhDistortionAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKFFTTap : ObjectiveC.NSObject, AudioKit.EZAudioFFTDelegate {
  final public let fftSize: AudioKit.AKSettings.BufferLength
  @objc open var fftData: [Swift.Double]
  public init(_ input: AudioKit.AKNode, fftSize: AudioKit.AKSettings.BufferLength = .veryLong)
  @objc open func fft(_ fft: AudioKit.EZAudioFFT!, updatedWithFFTData fftData: Swift.UnsafeMutablePointer<Swift.Float>, bufferSize: Accelerate.vDSP_Length)
  @objc deinit
  @objc override dynamic public init()
}
extension AKOperation {
  public func save(parameterIndex: Swift.Int) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKBitCrusherAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKCustomUgen : ObjectiveC.NSObject {
  @objc final public let name: Swift.String
  @objc final public let argTypes: Swift.String
  @objc open var userData: Any?
  final public let computeFunction: (AudioKit.AKCustomUgen, AudioKit.AKSporthStack, inout Any?) -> Swift.Void
  @objc public var stack: AudioKit.AKSporthStack
  public init(name: Swift.String, argTypes: Swift.String, userData: Any? = nil, computeFunction: @escaping (AudioKit.AKCustomUgen, AudioKit.AKSporthStack, inout Any?) -> Swift.Void)
  @objc public func duplicate() -> AudioKit.AKCustomUgen
  @objc final public let callComputeFunction: @convention(c) (AudioKit.AKCustomUgen) -> Swift.Void
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class AKConvolutionAudioUnit : AudioKit.AKAudioUnitBase {
  public func setPartitionLength(_ length: Swift.Int)
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKResonantFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public class AKScheduledAction {
  @objc public init(interval: Foundation.TimeInterval, block: @escaping () -> Swift.Void)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKMetalBarAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKHighPassButterworthFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public protocol AKMIDIMessage {
  var data: [Swift.UInt8] { get }
  var description: Swift.String { get }
}
@objc open class AKTuningTableETNN : ObjectiveC.NSObject {
  @objc public var nn: AudioKit.MIDINoteNumber
  @objc public var pitchBend: Swift.Int
  public init(_ nn: AudioKit.MIDINoteNumber = 60, _ pb: Swift.Int = 16_384 / 2)
  @objc deinit
  @objc override dynamic public init()
}
@objc open class AKTuningTableDelta12ET : ObjectiveC.NSObject {
  @objc public var nn: AudioKit.MIDINoteNumber
  @objc public var cents: Swift.Double
  public init(_ nn: AudioKit.MIDINoteNumber = 60, _ cents: Swift.Double = 0)
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers open class AKTuningTable : AudioKit.AKTuningTableBase {
  @objc public var masterSet: [AudioKit.AKTuningTable.Frequency] {
    get
  }
  @objc public var middleCNoteNumber: AudioKit.MIDINoteNumber {
    @objc get
    @objc set(value)
  }
  @objc public var middleCFrequency: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc public var middleCOctave: Swift.Int {
    @objc get
    @objc set(value)
  }
  @objc public var etNNPitchBendRangeDown: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc public var etNNPitchBendRangeUp: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc public func etNNPitchBend(NN nn: AudioKit.MIDINoteNumber) -> AudioKit.AKTuningTableETNN?
  @objc public func delta12ET(NN nn: AudioKit.MIDINoteNumber) -> AudioKit.AKTuningTableDelta12ET?
  @objc override public var npo: Swift.Int {
    @objc get
  }
  @objc override dynamic public init()
  @discardableResult
  @objc public func tuningTable(fromFrequencies inputMasterSet: [AudioKit.AKTuningTable.Frequency]) -> Swift.Int
  @objc open func tuning12ETDeviation(centsArray: [AudioKit.AKTuningTable.Cents])
  @objc public func masterSetInCents() -> [AudioKit.AKTuningTable.Cents]
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKVocalTractAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public class AKMicrophoneTracker {
  public var amplitude: Swift.Double {
    get
  }
  public var frequency: Swift.Double {
    get
  }
  public func start()
  public func stop()
  @objc public init(hopSize: Swift.Int = 4_096, peakCount: Swift.Int = 20)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AKAbstractPlayer : AudioKit.AKNode {
  public enum RenderingMode {
    case realtime
    case offline
    public static func == (a: AudioKit.AKAbstractPlayer.RenderingMode, b: AudioKit.AKAbstractPlayer.RenderingMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Fade {
    public static var linearTaper: (in: AudioToolbox.AUValue, out: AudioToolbox.AUValue)
    public static var audioTaper: (in: AudioToolbox.AUValue, out: AudioToolbox.AUValue)
    public static var reverseAudioTaper: (in: AudioToolbox.AUValue, out: AudioToolbox.AUValue)
    public init()
    public static var minimumGain: AudioToolbox.AUValue
    public var maximumGain: AudioToolbox.AUValue
    public var inTime: Swift.Double {
      get
      set(value)
    }
    public var inTaper: AudioToolbox.AUValue {
      get
      set(value)
    }
    public var inSkew: AudioToolbox.AUValue
    public var outTime: Swift.Double {
      get
      set(value)
    }
    public var outTaper: AudioToolbox.AUValue {
      get
      set(value)
    }
    public var outSkew: AudioToolbox.AUValue
  }
  public struct Loop {
    public init()
    public var start: Swift.Double {
      get
      set(value)
    }
    public var end: Swift.Double {
      get
      set(value)
    }
  }
  public var renderingMode: AudioKit.AKAbstractPlayer.RenderingMode {
    get
  }
  public var fade: AudioKit.AKAbstractPlayer.Fade
  public var loop: AudioKit.AKAbstractPlayer.Loop
  @objc public var faderNode: AudioKit.AKFader?
  @objc public var gain: AudioToolbox.AUValue {
    @objc get
    @objc set(newValue)
  }
  @objc open var startTime: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc open var endTime: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  public var offsetTime: Swift.Double
  @objc open var isPlaying: Swift.Bool {
    get
  }
  @objc open var isLooping: Swift.Bool
  @objc open var isFaded: Swift.Bool {
    @objc get
  }
  @objc open var duration: Swift.Double {
    @objc get
  }
  @objc open var sampleRate: Swift.Double {
    @objc get
  }
  open func initialize(restartIfPlaying: Swift.Bool = true)
  @objc open func play()
  @objc open func stop()
  public func startFader()
  public func bypassFader()
  public func resetFader()
  public func fadeOut(with duration: Swift.Double, taper: AudioToolbox.AUValue? = nil)
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
extension AKOperation {
  public static func vocalTract(frequency: AudioKit.AKParameter = 160.0, tonguePosition: AudioKit.AKParameter = 0.5, tongueDiameter: AudioKit.AKParameter = 1.0, tenseness: AudioKit.AKParameter = 0.6, nasality: AudioKit.AKParameter = 0.0) -> AudioKit.AKOperation
}
open class AKMusicTrack {
  open var internalMusicTrack: AudioToolbox.MusicTrack?
  open var initMusicTrack: AudioToolbox.MusicTrack?
  open var sequencer: AudioKit.AKAppleSequencer
  open var trackPointer: Swift.UnsafeMutablePointer<AudioToolbox.MusicTrack>?
  open var initTrackPointer: Swift.UnsafeMutablePointer<AudioToolbox.MusicTrack>?
  open var isNotEmpty: Swift.Bool {
    get
  }
  open var length: AudioToolbox.MusicTimeStamp {
    get
  }
  open var initLength: AudioToolbox.MusicTimeStamp {
    get
  }
  @objc public init(name: Swift.String = "Unnamed")
  @objc public init(musicTrack: AudioToolbox.MusicTrack, name: Swift.String = "Unnamed")
  public init(musicTrack: AudioToolbox.MusicTrack, sequencer: AudioKit.AKAppleSequencer)
  open func setNodeOutput(_ node: AudioToolbox.AUNode)
  open func setLoopInfo(_ duration: AudioKit.AKDuration, numberOfLoops: Swift.Int)
  open func setLength(_ duration: AudioKit.AKDuration)
  open func setLengthSoft(_ duration: AudioKit.AKDuration)
  open func clear()
  open func clearMetaEvents()
  open func clearSysexEvents()
  open func clearNote(_ note: AudioKit.MIDINoteNumber)
  open var isEmpty: Swift.Bool {
    get
  }
  open func clearRange(start: AudioKit.AKDuration, duration: AudioKit.AKDuration)
  open func add(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, position: AudioKit.AKDuration, duration: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func add(midiNoteData: AudioKit.AKMIDINoteData)
  open func replaceMIDINoteData(with trackMIDINoteData: [AudioKit.AKMIDINoteData])
  open func addController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, position: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func addAftertouch(_ noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, position: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func addChannelAftertouch(pressure: AudioKit.MIDIByte, position: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func addSysex(_ data: [AudioKit.MIDIByte], position: AudioKit.AKDuration)
  open func addPitchBend(_ value: Swift.Int = 8_192, position: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func resetPitchBend(position: AudioKit.AKDuration, channel: AudioKit.MIDIChannel = 0)
  open func getMIDINoteData() -> [AudioKit.AKMIDINoteData]
  open func copyAndMergeTo(musicTrack: AudioKit.AKMusicTrack)
  open func copyOf() -> AudioKit.AKMusicTrack?
  open func resetToInit()
  open func setMIDIOutput(_ endpoint: CoreMIDI.MIDIEndpointRef)
  @objc deinit
}
@objc public enum AKTableType : Swift.Int, Swift.Codable, Swift.CaseIterable {
  case sine
  case triangle
  case square
  case sawtooth
  case reverseSawtooth
  case positiveSine
  case positiveTriangle
  case positiveSquare
  case positiveSawtooth
  case positiveReverseSawtooth
  case zero
  case custom
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [AudioKit.AKTableType]
  public static var allCases: [AudioKit.AKTableType] {
    get
  }
}
@objc public class AKTable : ObjectiveC.NSObject, Swift.MutableCollection, Swift.Codable {
  public typealias Index = Swift.Int
  public typealias IndexDistance = Swift.Int
  public typealias Element = Swift.Float
  public typealias SubSequence = Swift.ArraySlice<AudioKit.AKTable.Element>
  public var content: [AudioKit.AKTable.Element] {
    get
  }
  public var phase: Swift.Float {
    get
    set(value)
  }
  public var startIndex: AudioKit.AKTable.Index {
    get
  }
  public var endIndex: AudioKit.AKTable.Index {
    get
  }
  public var count: AudioKit.AKTable.IndexDistance {
    get
  }
  public subscript(index: AudioKit.AKTable.Index) -> AudioKit.AKTable.Element {
    get
    set(newValue)
  }
  public subscript(bounds: Swift.Range<AudioKit.AKTable.Index>) -> AudioKit.AKTable.SubSequence {
    get
    set(newValue)
  }
  @objc public init(_ type: AudioKit.AKTableType = .sine, phase: Swift.Float = 0, count: AudioKit.AKTable.IndexDistance = 4_096)
  @objc public init(_ content: [AudioKit.AKTable.Element], phase: Swift.Float = 0)
  @objc public convenience init(file: AudioKit.AKAudioFile)
  public var phaseOffset: Swift.Int {
    @inline(__always) get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public typealias Iterator = Swift.IndexingIterator<AudioKit.AKTable>
}
extension AKTable : Swift.RandomAccessCollection {
  public typealias Indices = Swift.Array<AudioKit.AKTable.Element>.Indices
  @inline(__always) public func index(before i: AudioKit.AKTable.Index) -> AudioKit.AKTable.Index
  @inline(__always) public func index(after i: AudioKit.AKTable.Index) -> AudioKit.AKTable.Index
  @inline(__always) public func index(_ i: AudioKit.AKTable.Index, offsetBy n: AudioKit.AKTable.IndexDistance) -> AudioKit.AKTable.Index
  @inline(__always) public func formIndex(after i: inout AudioKit.AKTable.Index)
  @inline(__always) public func distance(from start: AudioKit.AKTable.Index, to end: AudioKit.AKTable.Index) -> AudioKit.AKTable.IndexDistance
}
public protocol Aliased {
  associatedtype _Self = Self
}
public protocol AUComponent : AnyObject, AudioKit.Aliased {
  static var ComponentDescription: AudioToolbox.AudioComponentDescription { get }
}
public protocol AKComponent : AudioKit.AUComponent {
  associatedtype AKAudioUnitType : AudioToolbox.AUAudioUnit
  var internalAU: Self.AKAudioUnitType? { get }
  var rampDuration: Swift.Double { get set }
}
extension AKComponent {
  public static func register()
  public func instantiateAudioUnit(callback: @escaping (AVFoundation.AVAudioUnit) -> Swift.Void)
  public var rampDuration: Swift.Double {
    get
    set(newValue)
  }
}
extension AUParameterTree {
  public subscript(key: Swift.String) -> AudioToolbox.AUParameter? {
    get
  }
}
extension AudioComponentDescription {
  public init(type: Darwin.OSType, subType: Darwin.OSType)
  public init(appleEffect subType: Darwin.OSType)
  public init(effect subType: Darwin.OSType)
  public init(effect subType: Swift.String)
  public init(mixer subType: Swift.String)
  public init(generator subType: Swift.String)
  public init(instrument subType: Swift.String)
}
@objc public protocol AKClip : AnyObject {
  @objc var time: Swift.Double { get }
  @objc var offset: Swift.Double { get }
  @objc var duration: Swift.Double { get }
}
extension AKClip {
  public func overlaps(_ otherClip: AudioKit.AKClip) -> Swift.Bool
  public var isValid: Swift.Bool {
    get
  }
  public var endTime: Swift.Double {
    get
  }
}
@objc public protocol FileClip : AudioKit.AKClip {
  @objc var audioFile: AudioKit.AKAudioFile { get }
}
@objc open class AKFileClip : ObjectiveC.NSObject, AudioKit.FileClip {
  @objc open var audioFile: AudioKit.AKAudioFile
  @objc open var time: Swift.Double
  @objc open var offset: Swift.Double
  @objc open var duration: Swift.Double
  @objc public init(audioFile: AudioKit.AKAudioFile, time: Swift.Double = 0, offset: Swift.Double = 0, duration: Swift.Double = 0)
  public convenience init?(url: Foundation.URL)
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class AKTremoloAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKDynamicRangeCompressorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKComputedParameter {
  public func moogLadderFilter(cutoffFrequency: AudioKit.AKParameter = 1_000, resonance: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
extension MIDIPacket : Swift.Sequence {
  public func makeIterator() -> Swift.AnyIterator<AudioKit.AKMIDIEvent>
  public typealias Element = AudioKit.AKMIDIEvent
  public typealias Iterator = Swift.AnyIterator<AudioKit.AKMIDIEvent>
}
@objc open class AKExpander : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var expansionRatio: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var expansionThreshold: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var masterGain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var compressionAmount: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var inputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var outputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, threshold: AudioToolbox.AUValue = -20, headRoom: AudioToolbox.AUValue = 5, expansionRatio: AudioToolbox.AUValue = 2, expansionThreshold: AudioToolbox.AUValue = 2, attackDuration: AudioToolbox.AUValue = 0.001, releaseDuration: AudioToolbox.AUValue = 0.05, masterGain: AudioToolbox.AUValue = 0, compressionAmount: AudioToolbox.AUValue = 0, inputAmplitude: AudioToolbox.AUValue = 0, outputAmplitude: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKExpander
}
public struct AKMIDIFileTrack {
  public var events: [AudioKit.AKMIDIEvent] {
    get
  }
  public var length: Swift.Double {
    get
  }
  public var name: Swift.String? {
    get
  }
}
@objc open class AKPitchShifter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPitchShifterAudioUnit
  public var internalAU: AudioKit.AKPitchShifter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var shiftRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var windowSizeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var crossfadeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultShift: AudioToolbox.AUValue
  public static var defaultWindowSize: AudioToolbox.AUValue
  public static var defaultCrossfade: AudioToolbox.AUValue
  final public let shift: AudioKit.AKNodeParameter
  final public let windowSize: AudioKit.AKNodeParameter
  final public let crossfade: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, shift: AudioToolbox.AUValue = defaultShift, windowSize: AudioToolbox.AUValue = defaultWindowSize, crossfade: AudioToolbox.AUValue = defaultCrossfade)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPitchShifter
}
extension AKOperation {
  public static func jitter(amplitude: AudioKit.AKParameter = 0.5, minimumFrequency: AudioKit.AKParameter = 0.5, maximumFrequency: AudioKit.AKParameter = 4) -> AudioKit.AKOperation
}
open class AKStereoOperation : AudioKit.AKComputedParameter {
  open var description: Swift.String {
    get
  }
  open func toMono() -> AudioKit.AKOperation
  open func left() -> AudioKit.AKOperation
  open func right() -> AudioKit.AKOperation
  open func toStereo() -> AudioKit.AKStereoOperation
  public static var input: AudioKit.AKStereoOperation
  public init(_ operationString: Swift.String)
  public init(module: Swift.String, setup: Swift.String = "", inputs: AudioKit.AKParameter...)
  @objc deinit
}
public struct AKMIDIEvent : AudioKit.AKMIDIMessage {
  public var data: [AudioKit.MIDIByte]
  public var positionInBeats: Swift.Double?
  public var offset: CoreMIDI.MIDITimeStamp
  public var description: Swift.String {
    get
  }
  public var internalPackets: [[AudioKit.MIDIByte]] {
    get
  }
  public var length: Swift.Int {
    get
  }
  public var status: AudioKit.AKMIDIStatus? {
    get
  }
  public var command: AudioKit.AKMIDISystemCommand? {
    get
  }
  public var channel: AudioKit.MIDIChannel? {
    get
  }
  public var noteNumber: AudioKit.MIDINoteNumber? {
    get
  }
  public var pitchbendAmount: AudioKit.MIDIWord? {
    get
  }
  public init(packet: CoreMIDI.MIDIPacket)
  public init(data: [AudioKit.MIDIByte], offset: CoreMIDI.MIDITimeStamp = 0)
  public init(noteOn noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel)
  public init(noteOff noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel)
  public init(programChange data: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel)
  public init(controllerChange controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel)
  public static func midiEventsFrom(packetListPointer: Swift.UnsafePointer<CoreMIDI.MIDIPacketList>) -> [AudioKit.AKMIDIEvent]
  public static func generateFrom(bluetoothData: [AudioKit.MIDIByte]) -> [AudioKit.AKMIDIEvent]
}
@objc @_inheritsConvenienceInitializers public class AKBrownianNoiseAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKOperation {
  public static func phasor(frequency: AudioKit.AKParameter = 1, phase: Swift.Double = 0) -> AudioKit.AKOperation
}
@objc open class AKBrownianNoise : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKBrownianNoiseAudioUnit
  public var internalAU: AudioKit.AKBrownianNoise.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let amplitude: AudioKit.AKNodeParameter
  public init(amplitude: AudioToolbox.AUValue = defaultAmplitude)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBrownianNoise
}
extension NSNotification.Name {
  public static var AKEngineRestartedAfterRouteChange: Foundation.Notification.Name
  public static var AKEngineRestartedAfterConfigurationChange: Foundation.Notification.Name
  public static var AKEngineStarted: Foundation.Notification.Name
}
extension AKOperation {
  public static func pluckedString(trigger: AudioKit.AKOperation, frequency: AudioKit.AKParameter = 110, amplitude: AudioKit.AKParameter = 0.5, lowestFrequency: Swift.Double = 110) -> AudioKit.AKOperation
}
open class AKSequencer {
  open var tracks: [AudioKit.AKSequencerTrack]
  open var tempo: AudioKit.BPM {
    get
    set(newValue)
  }
  open var length: Swift.Double {
    get
    set(newValue)
  }
  open var loopEnabled: Swift.Bool {
    get
    set(newValue)
  }
  open var isPlaying: Swift.Bool {
    get
  }
  public convenience init(targetNode: AudioKit.AKNode)
  required public init(targetNodes: [AudioKit.AKNode]? = nil)
  public convenience init(fromURL fileURL: Foundation.URL, targetNodes: [AudioKit.AKNode])
  open func play()
  open func playFromStart()
  open func playAfterDelay(beats: Swift.Double)
  open func stop()
  open func rewind()
  open func load(midiFileURL: Foundation.URL)
  open func load(midiFile: AudioKit.AKMIDIFile)
  open func add(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity = 127, channel: AudioKit.MIDIChannel = 0, position: Swift.Double, duration: Swift.Double, trackIndex: Swift.Int = 0)
  open func add(event: AudioKit.AKMIDIEvent, position: Swift.Double, trackIndex: Swift.Int = 0)
  open func clear()
  open func seek(to position: Swift.Double)
  open func pause()
  open func getTrackFor(node: AudioKit.AKNode) -> AudioKit.AKSequencerTrack?
  open func addTrack(for node: AudioKit.AKNode) -> AudioKit.AKSequencerTrack
  @objc deinit
}
@objc open class AKConvolution : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKConvolutionAudioUnit
  public var internalAU: AudioKit.AKConvolution.AKAudioUnitType? {
    get
  }
  public init(_ input: AudioKit.AKNode? = nil, impulseResponseFileURL: Foundation.URL, partitionLength: Swift.Int = 2_048)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKConvolution
}
extension AKComputedParameter {
  public func pan(_ pan: AudioKit.AKParameter = 0) -> AudioKit.AKStereoOperation
  public func stereoPan(_ pan: AudioKit.AKParameter = 0) -> AudioKit.AKStereoOperation
}
@objc open class AKDelay : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var time: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var feedback: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var lowPassCutoff: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, time: AudioToolbox.AUValue = 1, feedback: AudioToolbox.AUValue = 0.5, lowPassCutoff: AudioToolbox.AUValue = 15_000, dryWetMix: AudioToolbox.AUValue = 0.5)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
extension AKTable {
  public static func fromAudioFile(_ url: Foundation.URL) -> AudioKit.AKTable?
  public func writeToAudioFile(_ fileName: Swift.String) throws
}
@objc open class AKKorgLowPassFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKKorgLowPassFilterAudioUnit
  public var internalAU: AudioKit.AKKorgLowPassFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var resonanceRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var saturationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  public static var defaultResonance: AudioToolbox.AUValue
  public static var defaultSaturation: AudioToolbox.AUValue
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  final public let resonance: AudioKit.AKNodeParameter
  final public let saturation: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency, resonance: AudioToolbox.AUValue = defaultResonance, saturation: AudioToolbox.AUValue = defaultSaturation)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKKorgLowPassFilter
}
extension AKOperation {
  public func plus(_ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
  public func offsetBy(_ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
}
public func + (left: AudioKit.AKParameter, right: AudioKit.AKParameter) -> AudioKit.AKOperation
extension AKStereoOperation {
  public static func + (first: AudioKit.AKStereoOperation, second: AudioKit.AKStereoOperation) -> AudioKit.AKStereoOperation
}
@objc @_inheritsConvenienceInitializers public class AKFMOscillatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
public func max(_ x: AudioKit.AKComputedParameter, _ y: AudioKit.AKComputedParameter) -> AudioKit.AKOperation
public func max(_ operation: AudioKit.AKComputedParameter, _ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
public func max(_ parameter: AudioKit.AKParameter, _ operation: AudioKit.AKComputedParameter) -> AudioKit.AKOperation
extension AKOperation {
  public static func morphingOscillator(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 1, index: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKZitaReverbAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKPhaseLockedVocoder : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPhaseLockedVocoderAudioUnit
  public var internalAU: AudioKit.AKPhaseLockedVocoder.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var positionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var pitchRatioRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultPosition: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultPitchRatio: AudioToolbox.AUValue
  final public let position: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  final public let pitchRatio: AudioKit.AKNodeParameter
  public init(position: AudioToolbox.AUValue = defaultPosition, amplitude: AudioToolbox.AUValue = defaultAmplitude, pitchRatio: AudioToolbox.AUValue = defaultPitchRatio)
  public func copy() -> AudioKit.AKPhaseLockedVocoder
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPhaseLockedVocoder
}
extension AKMIDI {
  public func addListener(_ listener: AudioKit.AKMIDIListener)
  public func removeListener(_ listener: AudioKit.AKMIDIListener)
  public func clearListeners()
}
extension AKMIDI {
  public func addTransformer(_ transformer: AudioKit.AKMIDITransformer)
  public func removeTransformer(_ transformer: AudioKit.AKMIDITransformer)
  public func clearTransformers()
}
extension AKMIDI {
  public var inputUIDs: [CoreMIDI.MIDIUniqueID] {
    get
  }
  public var inputNames: [Swift.String] {
    get
  }
  public func inputName(for inputUid: CoreMIDI.MIDIUniqueID) -> Swift.String?
  public func uidForInputAtIndex(_ inputIndex: Swift.Int = 0) -> CoreMIDI.MIDIUniqueID
  public func openInput(name: Swift.String = "")
  public func openInput(index inputIndex: Swift.Int)
  public func openInput(uid inputUID: CoreMIDI.MIDIUniqueID)
  @available(*, deprecated, message: "Try to not use names any more because they are not unique across devices")
  public func closeInput(name: Swift.String)
  public func closeInput()
  public func closeInput(index inputIndex: Swift.Int)
  public func closeInput(uid inputUID: CoreMIDI.MIDIUniqueID)
  public func closeAllInputs()
}
@objc @_inheritsConvenienceInitializers public class AKPluckedStringAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AKStringResonatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKFMOscillator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKFMOscillatorAudioUnit
  public var internalAU: AudioKit.AKFMOscillator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var baseFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var carrierMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var modulatingMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var modulationIndexRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultBaseFrequency: AudioToolbox.AUValue
  public static var defaultCarrierMultiplier: AudioToolbox.AUValue
  public static var defaultModulatingMultiplier: AudioToolbox.AUValue
  public static var defaultModulationIndex: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let baseFrequency: AudioKit.AKNodeParameter
  final public let carrierMultiplier: AudioKit.AKNodeParameter
  final public let modulatingMultiplier: AudioKit.AKNodeParameter
  final public let modulationIndex: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  public init(waveform: AudioKit.AKTable = AKTable(.sine), baseFrequency: AudioToolbox.AUValue = defaultBaseFrequency, carrierMultiplier: AudioToolbox.AUValue = defaultCarrierMultiplier, modulatingMultiplier: AudioToolbox.AUValue = defaultModulatingMultiplier, modulationIndex: AudioToolbox.AUValue = defaultModulationIndex, amplitude: AudioToolbox.AUValue = defaultAmplitude)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFMOscillator
}
extension AKAudioFile {
  public static func silent(samples: Swift.Int64, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "") throws -> AudioKit.AKAudioFile
  public static func findPeak(pcmBuffer: AVFoundation.AVAudioPCMBuffer) -> Swift.Double
}
extension AKOperation {
  public func scale(minimum: AudioKit.AKParameter = 0, maximum: AudioKit.AKParameter = 1) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func korgLowPassFilter(cutoffFrequency: AudioKit.AKParameter = 1_000.0, resonance: AudioKit.AKParameter = 1.0, saturation: AudioKit.AKParameter = 0.0) -> AudioKit.AKOperation
}
@objc open class AKMIDIMonoPolyListener : ObjectiveC.NSObject {
  @objc public init(mono: Swift.Bool = true)
  @objc deinit
  @objc override dynamic public init()
}
extension AKMIDIMonoPolyListener : AudioKit.AKMIDIListener {
  public func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc dynamic public func monoPolyChange()
}
@objc @_inheritsConvenienceInitializers public class AKHighShelfParametricEqualizerFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKHighPassButterworthFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKHighPassButterworthFilterAudioUnit
  public var internalAU: AudioKit.AKHighPassButterworthFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKHighPassButterworthFilter
}
@objc open class AKPanner : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPannerAudioUnit
  public var internalAU: AudioKit.AKPanner.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var panRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultPan: AudioToolbox.AUValue
  final public let pan: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, pan: AudioToolbox.AUValue = defaultPan)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPanner
}
@objc open class AKTester : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public typealias AKAudioUnitType = AudioKit.AKTesterAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKTester.AKAudioUnitType? {
    get
  }
  open var MD5: Swift.String {
    get
  }
  @objc open var isStarted: Swift.Bool {
    @objc get
  }
  @objc public init(_ input: AudioKit.AKNode?, samples: Swift.Int)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKTester
}
extension AKTuningTable {
  @objc dynamic public func momentOfSymmetry(generator gInput: Swift.Double = 7.0 / 12.0, level lInput: Swift.Int = 5, murchana mInput: Swift.Int = 0) -> Swift.Int
}
@objc open class AKPeakLimiter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var preGain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, attackDuration: AudioToolbox.AUValue = 0.012, decayDuration: AudioToolbox.AUValue = 0.024, preGain: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPeakLimiter
}
@objc open class AKMIDIInstrument : AudioKit.AKPolyphonicNode, AudioKit.AKMIDIListener {
  open var midiIn: CoreMIDI.MIDIEndpointRef
  open var name: Swift.String
  open var mpeActiveNotes: [(note: AudioKit.MIDINoteNumber, channel: AudioKit.MIDIChannel)]
  public init(midiInputName: Swift.String? = nil)
  open func enableMIDI(_ midiClient: CoreMIDI.MIDIClientRef = AKManager.midi.client, name: Swift.String = "AudioKit MIDI Instrument")
  open func receivedMIDINoteOn(_ noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  open func receivedMIDINoteOff(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  open func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  open func receivedMIDIAftertouch(noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  open func receivedMIDIAftertouch(_ pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  open func receivedMIDIPitchWheel(_ pitchWheelValue: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc open func start(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc open func stop(noteNumber: AudioKit.MIDINoteNumber, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc open func receivedMIDIProgramChange(_ program: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKChowningReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKChowningReverbAudioUnit
  public var internalAU: AudioKit.AKChowningReverb.AKAudioUnitType? {
    get
  }
  public init(_ input: AudioKit.AKNode? = nil)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKChowningReverb
}
@objc open class AKFMOscillatorFilterSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKFMOscillatorFilterSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKFMOscillatorFilterSynth.AKAudioUnitType? {
    get
  }
  @objc open var waveform: AudioKit.AKTable? {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var carrierMultiplier: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var modulatingMultiplier: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var modulationIndex: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterCutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterEnvelopeStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFODepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFORate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), carrierMultiplier: AudioToolbox.AUValue = 1, modulatingMultiplier: AudioToolbox.AUValue = 1, modulationIndex: AudioToolbox.AUValue = 1, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0, filterCutoffFrequency: AudioToolbox.AUValue = 22_050.0, filterResonance: AudioToolbox.AUValue = 0.0, filterAttackDuration: AudioToolbox.AUValue = 0.1, filterDecayDuration: AudioToolbox.AUValue = 0.1, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 1.0, filterEnvelopeStrength: AudioToolbox.AUValue = 0.0, filterLFODepth: AudioToolbox.AUValue = 0.0, filterLFORate: AudioToolbox.AUValue = 0.0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFMOscillatorFilterSynth
}
@objc open class AKLowShelfFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var cutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var gain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = 80, gain: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKLowShelfFilter
}
@objc open class AKOscillatorBank : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKOscillatorBankAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKOscillatorBank.AKAudioUnitType? {
    get
  }
  @objc open var waveform: AudioKit.AKTable? {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0)
  open func reset()
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKOscillatorBank
}
@objc open class AKMetalBar : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKMetalBarAudioUnit
  public var internalAU: AudioKit.AKMetalBar.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var leftBoundaryConditionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var rightBoundaryConditionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var decayDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var scanSpeedRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var positionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var strikeVelocityRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var strikeWidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultLeftBoundaryCondition: AudioToolbox.AUValue
  public static var defaultRightBoundaryCondition: AudioToolbox.AUValue
  public static var defaultDecayDuration: AudioToolbox.AUValue
  public static var defaultScanSpeed: AudioToolbox.AUValue
  public static var defaultPosition: AudioToolbox.AUValue
  public static var defaultStrikeVelocity: AudioToolbox.AUValue
  public static var defaultStrikeWidth: AudioToolbox.AUValue
  public static var defaultStiffness: AudioToolbox.AUValue
  public static var defaultHighFrequencyDamping: AudioToolbox.AUValue
  final public let leftBoundaryCondition: AudioKit.AKNodeParameter
  final public let rightBoundaryCondition: AudioKit.AKNodeParameter
  final public let decayDuration: AudioKit.AKNodeParameter
  final public let scanSpeed: AudioKit.AKNodeParameter
  final public let position: AudioKit.AKNodeParameter
  final public let strikeVelocity: AudioKit.AKNodeParameter
  final public let strikeWidth: AudioKit.AKNodeParameter
  public init(leftBoundaryCondition: AudioToolbox.AUValue = defaultLeftBoundaryCondition, rightBoundaryCondition: AudioToolbox.AUValue = defaultRightBoundaryCondition, decayDuration: AudioToolbox.AUValue = defaultDecayDuration, scanSpeed: AudioToolbox.AUValue = defaultScanSpeed, position: AudioToolbox.AUValue = defaultPosition, strikeVelocity: AudioToolbox.AUValue = defaultStrikeVelocity, strikeWidth: AudioToolbox.AUValue = defaultStrikeWidth, stiffness: AudioToolbox.AUValue = defaultStiffness, highFrequencyDamping: AudioToolbox.AUValue = defaultHighFrequencyDamping)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKMetalBar
}
@objc open class AKCostelloReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKCostelloReverbAudioUnit
  public var internalAU: AudioKit.AKCostelloReverb.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFeedback: AudioToolbox.AUValue
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  final public let feedback: AudioKit.AKNodeParameter
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, feedback: AudioToolbox.AUValue = defaultFeedback, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKCostelloReverb
}
extension AKAudioFile {
  public convenience init(readFileName name: Swift.String, baseDir: AudioKit.AKAudioFile.BaseDirectory = .resources) throws
  public convenience init(writeIn baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String? = nil, settings: [Swift.String : Any] = AKSettings.audioFormat.settings) throws
  public convenience init(createFileFromFloats floatsArrays: [[Swift.Float]], baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "") throws
  public convenience init(fromAVAudioPCMBuffer buffer: AVFoundation.AVAudioPCMBuffer, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "") throws
}
extension AKComputedParameter {
  public func reverberateWithCostello(feedback: AudioKit.AKParameter = 0.6, cutoffFrequency: AudioKit.AKParameter = 4_000) -> AudioKit.AKStereoOperation
}
public protocol AKMIDIListener {
  func receivedMIDINoteOn(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDINoteOff(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDIAftertouch(noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDIAftertouch(_ pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDIPitchWheel(_ pitchWheelValue: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDIProgramChange(_ program: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDISystemCommand(_ data: [AudioKit.MIDIByte], portID: CoreMIDI.MIDIUniqueID?, offset: CoreMIDI.MIDITimeStamp)
  func receivedMIDISetupChange()
  func receivedMIDIPropertyChange(propertyChangeInfo: CoreMIDI.MIDIObjectPropertyChangeNotification)
  func receivedMIDINotification(notification: CoreMIDI.MIDINotification)
}
extension AKMIDIListener {
  public func receivedMIDINoteOn(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDINoteOff(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDIAftertouch(noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDIAftertouch(_ pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDIPitchWheel(_ pitchWheelValue: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDIProgramChange(_ program: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDISystemCommand(_ data: [AudioKit.MIDIByte], portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  public func receivedMIDISetupChange()
  public func receivedMIDIPropertyChange(propertyChangeInfo: CoreMIDI.MIDIObjectPropertyChangeNotification)
  public func receivedMIDINotification(notification: CoreMIDI.MIDINotification)
  public func isEqualTo(_ listener: AudioKit.AKMIDIListener) -> Swift.Bool
}
@objc open class AKDrip : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKDripAudioUnit
  public var internalAU: AudioKit.AKDrip.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var intensityRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dampingFactorRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var energyReturnRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var mainResonantFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var firstResonantFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var secondResonantFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultIntensity: AudioToolbox.AUValue
  public static var defaultDampingFactor: AudioToolbox.AUValue
  public static var defaultEnergyReturn: AudioToolbox.AUValue
  public static var defaultMainResonantFrequency: AudioToolbox.AUValue
  public static var defaultFirstResonantFrequency: AudioToolbox.AUValue
  public static var defaultSecondResonantFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let intensity: AudioKit.AKNodeParameter
  final public let dampingFactor: AudioKit.AKNodeParameter
  final public let energyReturn: AudioKit.AKNodeParameter
  final public let mainResonantFrequency: AudioKit.AKNodeParameter
  final public let firstResonantFrequency: AudioKit.AKNodeParameter
  final public let secondResonantFrequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  public init(intensity: AudioToolbox.AUValue = defaultIntensity, dampingFactor: AudioToolbox.AUValue = defaultDampingFactor, energyReturn: AudioToolbox.AUValue = defaultEnergyReturn, mainResonantFrequency: AudioToolbox.AUValue = defaultMainResonantFrequency, firstResonantFrequency: AudioToolbox.AUValue = defaultFirstResonantFrequency, secondResonantFrequency: AudioToolbox.AUValue = defaultSecondResonantFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude)
  open func trigger()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDrip
}
extension AKAudioFile {
  public typealias AsyncProcessCallback = (AudioKit.AKAudioFile?, Foundation.NSError?) -> Swift.Void
  public enum ExportFormat {
    case wav
    case aif
    case mp4
    case m4a
    case caf
    public static func == (a: AudioKit.AKAudioFile.ExportFormat, b: AudioKit.AKAudioFile.ExportFormat) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var queuedAsyncProcessCount: Swift.Int {
    get
  }
  public static var scheduledAsyncProcessesCount: Swift.Int {
    get
  }
  public static var completedAsyncProcessesCount: Swift.Int {
    get
  }
  public func normalizeAsynchronously(baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "", newMaxLevel: Swift.Float = 0.0, completionHandler: @escaping AudioKit.AKAudioFile.AsyncProcessCallback)
  public func reverseAsynchronously(baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "", completionHandler: @escaping AudioKit.AKAudioFile.AsyncProcessCallback)
  public func appendAsynchronously(file: AudioKit.AKAudioFile, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "", completionHandler: @escaping AudioKit.AKAudioFile.AsyncProcessCallback)
  public func extractAsynchronously(fromSample: Swift.Int64 = 0, toSample: Swift.Int64 = 0, baseDir: AudioKit.AKAudioFile.BaseDirectory = .temp, name: Swift.String = "", completionHandler: @escaping AudioKit.AKAudioFile.AsyncProcessCallback)
  public func exportAsynchronously(name: Swift.String, baseDir: AudioKit.AKAudioFile.BaseDirectory, exportFormat: AudioKit.AKAudioFile.ExportFormat, fromSample: AudioKit.Sample = 0, toSample: AudioKit.Sample = 0, callback: @escaping AudioKit.AKAudioFile.AsyncProcessCallback)
}
extension AKOperation {
  public static func pinkNoise(amplitude: AudioKit.AKParameter = 1.0) -> AudioKit.AKOperation
}
public func CheckError(_ error: Darwin.OSStatus)
public typealias AKThresholdCallback = @convention(block) (Swift.Bool) -> Swift.Void
@objc open class AKAmplitudeTracker : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public typealias AKAudioUnitType = AudioKit.AKAmplitudeTrackerAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKAmplitudeTracker.AKAudioUnitType? {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open var amplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var leftAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var rightAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var threshold: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  open var mode: AudioKit.AmplitudeTrackingMode {
    get
    set(value)
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, halfPowerPoint: AudioToolbox.AUValue = 10, threshold: AudioToolbox.AUValue = 1, thresholdCallback: @escaping AudioKit.AKThresholdCallback = { _ in })
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKAmplitudeTracker
}
public enum AmplitudeTrackingMode : Swift.Int32 {
  case rms
  case maxRMS
  case peak
  public typealias RawValue = Swift.Int32
  public init?(rawValue: Swift.Int32)
  public var rawValue: Swift.Int32 {
    get
  }
}
@_hasMissingDesignatedInitializers public class MIDIHelper {
  public static func convertTo16Bit(msb: Swift.UInt8, lsb: Swift.UInt8) -> Swift.UInt16
  public static func convertTo32Bit(msb: Swift.UInt8, data1: Swift.UInt8, data2: Swift.UInt8, lsb: Swift.UInt8) -> Swift.UInt32
  public static func convertToString(bytes: [Swift.UInt8]) -> Swift.String
  @objc deinit
}
@objc open class AKLowPassFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var cutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var resonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = 6_900, resonance: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKLowPassFilter
}
@objc @_inheritsConvenienceInitializers public class AKPhaseDistortionOscillatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc public class AKPeriodicFunction : AudioKit.AKOperationGenerator {
  @objc public init(every period: Swift.Double, handler: @escaping () -> Swift.Void)
  public convenience init(frequency: Swift.Double, handler: @escaping () -> Swift.Void)
  @objc deinit
  @objc override public init(sporth: Swift.String = super, customUgens: [AudioKit.AKCustomUgen] = super)
}
extension AKComputedParameter {
  public func highPassButterworthFilter(cutoffFrequency: AudioKit.AKParameter = 500) -> AudioKit.AKComputedParameter
}
@objc @_inheritsConvenienceInitializers public class AKAutoWahAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKTimePitch : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var rate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open var pitch: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var overlap: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, rate: AudioToolbox.AUValue = 1.0, pitch: AudioToolbox.AUValue = 0.0, overlap: AudioToolbox.AUValue = 8.0)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKVariSpeed : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  @objc dynamic open var rate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, rate: AudioToolbox.AUValue = 1.0)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
extension AKOperation {
  public func dividedBy(_ denominator: AudioKit.AKParameter) -> AudioKit.AKOperation
}
public func / (numerator: AudioKit.AKParameter, denominator: AudioKit.AKParameter) -> AudioKit.AKOperation
public func / (numerator: AudioKit.AKStereoOperation, denominator: AudioKit.AKParameter) -> AudioKit.AKStereoOperation
public protocol AKComputedParameter : AudioKit.AKParameter {
}
@_hasMissingDesignatedInitializers open class AKOperation : AudioKit.AKComputedParameter {
  open var description: Swift.String {
    get
  }
  public static var leftInput: AudioKit.AKOperation
  public static var rightInput: AudioKit.AKOperation
  public static var trigger: AudioKit.AKOperation
  public static var parameters: [AudioKit.AKOperation]
  open func toMono() -> AudioKit.AKOperation
  open func abs() -> AudioKit.AKOperation
  open func floor() -> AudioKit.AKOperation
  open func fract() -> AudioKit.AKOperation
  open func log() -> AudioKit.AKOperation
  open func log10() -> AudioKit.AKOperation
  open func round() -> AudioKit.AKOperation
  open func midiNoteToFrequency() -> AudioKit.AKOperation
  public init(_ value: Swift.Double)
  public init(_ operationString: Swift.String)
  public init(module: Swift.String, setup: Swift.String = "", inputs: AudioKit.AKParameter...)
  @objc deinit
}
public func abs(_ parameter: AudioKit.AKOperation) -> AudioKit.AKOperation
public func floor(_ operation: AudioKit.AKOperation) -> AudioKit.AKOperation
public func fract(_ operation: AudioKit.AKOperation) -> AudioKit.AKOperation
public func log(_ operation: AudioKit.AKOperation) -> AudioKit.AKOperation
public func log10(_ operation: AudioKit.AKOperation) -> AudioKit.AKOperation
public func round(_ operation: AudioKit.AKOperation) -> AudioKit.AKOperation
extension AKOperation {
  public static func square(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5, phase: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKToneFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKStereoFieldLimiter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public typealias AKAudioUnitType = AudioKit.AKStereoFieldLimiterAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKStereoFieldLimiter.AKAudioUnitType? {
    get
  }
  @objc open var amount: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc open var isStarted: Swift.Bool {
    @objc get
  }
  public init(_ input: AudioKit.AKNode? = nil, amount: Swift.Double = 1)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKStereoFieldLimiter
}
@objc open class AKThreePoleLowpassFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKThreePoleLowpassFilterAudioUnit
  public var internalAU: AudioKit.AKThreePoleLowpassFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var distortionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var resonanceRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultDistortion: AudioToolbox.AUValue
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  public static var defaultResonance: AudioToolbox.AUValue
  final public let distortion: AudioKit.AKNodeParameter
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  final public let resonance: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, distortion: AudioToolbox.AUValue = defaultDistortion, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency, resonance: AudioToolbox.AUValue = defaultResonance)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKThreePoleLowpassFilter
}
@objc open class AKBandPassButterworthFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKBandPassButterworthFilterAudioUnit
  public var internalAU: AudioKit.AKBandPassButterworthFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var bandwidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultBandwidth: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let bandwidth: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, bandwidth: AudioToolbox.AUValue = defaultBandwidth)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBandPassButterworthFilter
}
@objc open class AKVariableDelay : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKVariableDelayAudioUnit
  public var internalAU: AudioKit.AKVariableDelay.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var defaultTime: AudioToolbox.AUValue
  public static var defaultFeedback: AudioToolbox.AUValue
  public static var defaultMaximumDelayTime: AudioToolbox.AUValue
  final public let time: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, time: AudioToolbox.AUValue = defaultTime, feedback: AudioToolbox.AUValue = defaultFeedback, maximumDelayTime: AudioToolbox.AUValue = defaultMaximumDelayTime)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKVariableDelay
}
@objc open class AKOperationEffect : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput {
  public typealias AKAudioUnitType = AudioKit.AKOperationEffectAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKOperationEffect.AKAudioUnitType? {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open var parameters: [Swift.Double] {
    @objc get
    @objc set(newValue)
  }
  public convenience init(_ input: AudioKit.AKNode?, channelCount: Swift.Int, operations: (AudioKit.AKStereoOperation, [AudioKit.AKOperation]) -> [AudioKit.AKOperation])
  public convenience init(_ input: AudioKit.AKNode?, operation: (AudioKit.AKStereoOperation, [AudioKit.AKOperation]) -> AudioKit.AKComputedParameter)
  @objc public init(_ input: AudioKit.AKNode?, sporth: Swift.String, customUgens: [AudioKit.AKCustomUgen] = [])
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKOperationEffect
}
extension AKOperation {
  public static func periodicTrigger(period: AudioKit.AKParameter = 1.0) -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers public class AKBalancerAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc deinit
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = super) throws
}
@objc @_inheritsConvenienceInitializers public class AKOscillatorAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKFMOscillatorBank : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKFMOscillatorBankAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKFMOscillatorBank.AKAudioUnitType? {
    get
  }
  @objc open var waveform: AudioKit.AKTable? {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var carrierMultiplier: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var modulatingMultiplier: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var modulationIndex: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), carrierMultiplier: AudioToolbox.AUValue = 1, modulatingMultiplier: AudioToolbox.AUValue = 1, modulationIndex: AudioToolbox.AUValue = 1, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFMOscillatorBank
}
@objc open class AKWhiteNoise : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKWhiteNoiseAudioUnit
  public var internalAU: AudioKit.AKWhiteNoise.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let amplitude: AudioKit.AKNodeParameter
  public init(amplitude: AudioToolbox.AUValue = defaultAmplitude)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKWhiteNoise
}
@objc @_inheritsConvenienceInitializers public class AKBandPassButterworthFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKPWMOscillator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPWMOscillatorAudioUnit
  public var internalAU: AudioKit.AKPWMOscillator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation?
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var pulseWidthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningOffsetRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultPulseWidth: AudioToolbox.AUValue
  public static var defaultDetuningOffset: AudioToolbox.AUValue
  public static var defaultDetuningMultiplier: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  final public let pulseWidth: AudioKit.AKNodeParameter
  final public let detuningOffset: AudioKit.AKNodeParameter
  final public let detuningMultiplier: AudioKit.AKNodeParameter
  public init(frequency: AudioToolbox.AUValue = defaultFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude, pulseWidth: AudioToolbox.AUValue = defaultPulseWidth, detuningOffset: AudioToolbox.AUValue = defaultDetuningOffset, detuningMultiplier: AudioToolbox.AUValue = defaultDetuningMultiplier)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPWMOscillator
}
public protocol AKAutomatable : AnyObject {
  var parameterAutomation: AudioKit.AKParameterAutomation? { get }
}
@objc open class AKFlatFrequencyResponseReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKFlatFrequencyResponseReverbAudioUnit
  public var internalAU: AudioKit.AKFlatFrequencyResponseReverb.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var reverbDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultReverbDuration: AudioToolbox.AUValue
  public static var defaultLoopDuration: AudioToolbox.AUValue
  final public let reverbDuration: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, reverbDuration: AudioToolbox.AUValue = defaultReverbDuration, loopDuration: AudioToolbox.AUValue = defaultLoopDuration)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFlatFrequencyResponseReverb
}
extension AKMIDI {
  public var destinationUIDs: [CoreMIDI.MIDIUniqueID] {
    get
  }
  public var destinationNames: [Swift.String] {
    get
  }
  public func destinationName(for destUid: CoreMIDI.MIDIUniqueID) -> Swift.String
  public func uidForDestinationAtIndex(_ outputIndex: Swift.Int = 0) -> CoreMIDI.MIDIUniqueID
  @available(*, deprecated, message: "Try to not use names any more because they are not unique across devices")
  public func openOutput(name: Swift.String)
  public func openOutput()
  public func openOutput(index outputIndex: Swift.Int)
  public func openOutput(uid outputUid: CoreMIDI.MIDIUniqueID)
  public func closeOutput(name: Swift.String = "")
  public func closeOutput(index outputIndex: Swift.Int)
  public func closeOutput(uid outputUid: CoreMIDI.MIDIUniqueID)
  public func sendMessage(_ data: [AudioKit.MIDIByte], offset: CoreMIDI.MIDITimeStamp = 0)
  public func clearEndpoints()
  public func sendEvent(_ event: AudioKit.AKMIDIEvent)
  public func sendNoteOnMessage(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0)
  public func sendNoteOffMessage(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0)
  public func sendControllerMessage(_ control: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel = 0)
  public func sendPitchBendMessage(value: Swift.UInt16, channel: AudioKit.MIDIChannel = 0)
  public func sendNoteOnMessageWithTime(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0, time: CoreMIDI.MIDITimeStamp = 0)
  public func sendNoteOffMessageWithTime(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0, time: CoreMIDI.MIDITimeStamp = 0)
  public func sendMessageWithTime(_ data: [Swift.UInt8], time: CoreMIDI.MIDITimeStamp)
}
extension AKComputedParameter {
  public func highPassFilter(halfPowerPoint: AudioKit.AKParameter = 1_000) -> AudioKit.AKOperation
}
@objc open class AKMicrophone : AudioKit.AKNode, AudioKit.AKToggleable {
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public func setDevice(_ device: AudioKit.AKDevice) throws
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc public init?(with format: AVFoundation.AVAudioFormat? = nil)
  @objc open func start()
  @objc open func stop()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKFlanger : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKFlangerAudioUnit
  public var internalAU: AudioKit.AKFlanger.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var depthRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dryWetMixRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: Swift.Float
  public static var defaultDepth: Swift.Float
  public static var defaultFeedback: Swift.Float
  public static var defaultDryWetMix: Swift.Float
  final public let frequency: AudioKit.AKNodeParameter
  final public let depth: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  final public let dryWetMix: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = defaultFrequency, depth: AudioToolbox.AUValue = defaultDepth, feedback: AudioToolbox.AUValue = defaultFeedback, dryWetMix: AudioToolbox.AUValue = defaultDryWetMix)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFlanger
}
@objc open class AK3DPanner : AudioKit.AKNode, AudioKit.AKInput {
  @objc dynamic open var x: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var y: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var z: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, x: AudioToolbox.AUValue = 0, y: AudioToolbox.AUValue = 0, z: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc open class AKRolandTB303Filter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKRolandTB303FilterAudioUnit
  public var internalAU: AudioKit.AKRolandTB303Filter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var resonanceRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var distortionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var resonanceAsymmetryRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  public static var defaultResonance: AudioToolbox.AUValue
  public static var defaultDistortion: AudioToolbox.AUValue
  public static var defaultResonanceAsymmetry: AudioToolbox.AUValue
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  final public let resonance: AudioKit.AKNodeParameter
  final public let distortion: AudioKit.AKNodeParameter
  final public let resonanceAsymmetry: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency, resonance: AudioToolbox.AUValue = defaultResonance, distortion: AudioToolbox.AUValue = defaultDistortion, resonanceAsymmetry: AudioToolbox.AUValue = defaultResonanceAsymmetry)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKRolandTB303Filter
}
@objc open class AKSampler : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKSamplerAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKSampler.AKAudioUnitType?
  open var masterVolume: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchBend: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var vibratoDepth: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var vibratoFrequency: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var voiceVibratoDepth: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var voiceVibratoFrequency: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterCutoff: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterStrength: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterResonance: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var glideRate: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var attackDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var holdDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var decayDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var sustainLevel: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var releaseHoldDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var releaseDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterAttackDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterDecayDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterSustainLevel: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterReleaseDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchAttackDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchDecayDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchSustainLevel: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchReleaseDuration: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var pitchADSRSemitones: AudioToolbox.AUValue {
    get
    set(value)
  }
  @objc dynamic open var restartVoiceLFO: Swift.Bool {
    @objc get
    @objc set(value)
  }
  open var filterEnable: Swift.Bool {
    get
    set(value)
  }
  open var loopThruRelease: Swift.Bool {
    get
    set(value)
  }
  open var isMonophonic: Swift.Bool {
    get
    set(value)
  }
  open var isLegato: Swift.Bool {
    get
    set(value)
  }
  open var keyTrackingFraction: AudioToolbox.AUValue {
    get
    set(value)
  }
  open var filterEnvelopeVelocityScaling: AudioToolbox.AUValue {
    get
    set(value)
  }
  public init()
  open func loadAKAudioFile(from sampleDescriptor: AudioKit.AKSampleDescriptor, file: AudioKit.AKAudioFile)
  open func stopAllVoices()
  open func restartVoices()
  open func loadRawSampleData(from sampleDataDescriptor: AudioKit.AKSampleDataDescriptor)
  open func loadCompressedSampleFile(from sampleFileDescriptor: AudioKit.AKSampleFileDescriptor)
  open func unloadAllSamples()
  open func setNoteFrequency(noteNumber: AudioKit.MIDINoteNumber, frequency: AudioToolbox.AUValue)
  open func buildSimpleKeyMap()
  open func buildKeyMap()
  open func setLoop(thruRelease: Swift.Bool)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  open func silence(noteNumber: AudioKit.MIDINoteNumber)
  open func sustainPedal(pedalDown: Swift.Bool)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKSampler
}
extension AKComputedParameter {
  public func dcBlock() -> AudioKit.AKOperation
}
@objc @_inheritsConvenienceInitializers open class AKAppleSequencer : ObjectiveC.NSObject {
  open var sequence: AudioToolbox.MusicSequence?
  open var sequencePointer: Swift.UnsafeMutablePointer<AudioToolbox.MusicSequence>?
  open var tracks: [AudioKit.AKMusicTrack]
  open var loopEnabled: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
  public convenience init(filename: Swift.String)
  public convenience init(fromURL fileURL: Foundation.URL)
  public convenience init(fromData data: Foundation.Data)
  open func preroll()
  open func toggleLoop()
  open func enableLooping()
  open func enableLooping(_ loopLength: AudioKit.AKDuration)
  open func disableLooping()
  open func setLoopInfo(_ duration: AudioKit.AKDuration, numberOfLoops: Swift.Int)
  open func setLength(_ length: AudioKit.AKDuration)
  open var length: AudioKit.AKDuration {
    get
  }
  open func setRate(_ rate: Swift.Double)
  open var rate: Swift.Double {
    get
  }
  open func setTempo(_ bpm: Swift.Double)
  open func addTempoEventAt(tempo bpm: Swift.Double, position: AudioKit.AKDuration)
  open var tempo: Swift.Double {
    get
  }
  open var allTempoEvents: [(AudioToolbox.MusicTimeStamp, Swift.Double)] {
    get
  }
  open func getTempo(at position: AudioToolbox.MusicTimeStamp) -> Swift.Double
  open var allTimeSignatureEvents: [(AudioToolbox.MusicTimeStamp, AudioKit.AKTimeSignature)] {
    get
  }
  open func getTimeSignature(at position: AudioToolbox.MusicTimeStamp) -> AudioKit.AKTimeSignature
  open func addTimeSignatureEvent(at timeStamp: AudioToolbox.MusicTimeStamp = 0.0, timeSignature: AudioKit.AKTimeSignature, ticksPerMetronomeClick: Swift.UInt8 = 24, thirtySecondNotesPerQuarter: Swift.UInt8 = 8, clearExistingEvents: Swift.Bool = true)
  open func duration(seconds: Swift.Double) -> AudioKit.AKDuration
  open func seconds(duration: AudioKit.AKDuration) -> Swift.Double
  open func play()
  @objc open func stop()
  open func rewind()
  open var isPlaying: Swift.Bool {
    get
  }
  open var currentPosition: AudioKit.AKDuration {
    get
  }
  open var currentRelativePosition: AudioKit.AKDuration {
    get
  }
  open var trackCount: Swift.Int {
    get
  }
  open var timeResolution: Swift.UInt32 {
    get
  }
  open func loadMIDIFile(_ filename: Swift.String)
  open func loadMIDIFile(fromURL fileURL: Foundation.URL)
  open func loadMIDIFile(fromData data: Foundation.Data)
  open func addMIDIFileTracks(_ filename: Swift.String, useExistingSequencerLength: Swift.Bool = true)
  open func addMIDIFileTracks(_ url: Foundation.URL, useExistingSequencerLength: Swift.Bool = true)
  open func newTrack(_ name: Swift.String = "Unnamed") -> AudioKit.AKMusicTrack?
  open func deleteTrack(trackIndex: Swift.Int)
  open func clearRange(start: AudioKit.AKDuration, duration: AudioKit.AKDuration)
  open func setTime(_ time: AudioToolbox.MusicTimeStamp)
  open func genData() -> Foundation.Data?
  open func debug()
  open func setGlobalMIDIOutput(_ midiEndpoint: CoreMIDI.MIDIEndpointRef)
  open func nearestQuantizedPosition(quantizationInBeats: Swift.Double) -> AudioKit.AKDuration
  open func previousQuantizedPosition(quantizationInBeats: Swift.Double) -> AudioKit.AKDuration
  open func nextQuantizedPosition(quantizationInBeats: Swift.Double) -> AudioKit.AKDuration
}
@objc open class AKPWMOscillatorFilterSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKPWMOscillatorFilterSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKPWMOscillatorFilterSynth.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pulseWidth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterCutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterEnvelopeStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFODepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFORate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(pulseWidth: AudioToolbox.AUValue = 0.5, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0, filterCutoffFrequency: AudioToolbox.AUValue = 22_050.0, filterResonance: AudioToolbox.AUValue = 0.0, filterAttackDuration: AudioToolbox.AUValue = 0.1, filterDecayDuration: AudioToolbox.AUValue = 0.1, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 1.0, filterEnvelopeStrength: AudioToolbox.AUValue = 0.0, filterLFODepth: AudioToolbox.AUValue = 0.0, filterLFORate: AudioToolbox.AUValue = 0.0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPWMOscillatorFilterSynth
}
extension AKDistortion {
  public func presetInfiniteDistortionWall()
  public func printCurrentValuesAsPreset()
}
@objc @_inheritsConvenienceInitializers public class AKChorusAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
extension AKOperation {
  public static func sawtoothWave(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func lineSegment(trigger: AudioKit.AKOperation, start: AudioKit.AKParameter, end: AudioKit.AKParameter, duration: AudioKit.AKParameter) -> AudioKit.AKOperation
}
extension AKOperation {
  public static func exponentialSegment(trigger: AudioKit.AKOperation, start: AudioKit.AKParameter, end: AudioKit.AKParameter, duration: AudioKit.AKParameter) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func threePoleLowPassFilter(distortion: AudioKit.AKParameter = 0.5, cutoffFrequency: AudioKit.AKParameter = 1_500, resonance: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func delay(time: Swift.Double = 1.0, feedback: AudioKit.AKParameter = 0.0) -> AudioKit.AKOperation
}
public typealias ClipRecordingCompletion = (AudioKit.ClipRecordingResult) -> Swift.Void
public struct ClipRecording {
  public let url: Foundation.URL
  public let startTime: Swift.Double
  public let duration: Swift.Double
}
public enum ClipRecordingResult {
  case clip(AudioKit.ClipRecording)
  case error(Swift.Error)
}
open class AKClipRecorder {
  open var node: AudioKit.AKOutput
  @objc public init(node: AudioKit.AKOutput)
  @objc deinit
  open func start()
  @objc open func start(at audioTime: AVFoundation.AVAudioTime?)
  open var currentTime: Swift.Double {
    get
    set(newValue)
  }
  open func stop(_ completion: (() -> Swift.Void)? = nil)
  open func stopRecording(endTime: Swift.Double? = nil, _ completion: (() -> Swift.Void)? = nil)
  open var isRecording: Swift.Bool {
    get
  }
  public func recordClip(time: Swift.Double = 0, duration: Swift.Double = Double.greatestFiniteMagnitude, tap: AVFoundation.AVAudioNodeTapBlock? = nil, completion: @escaping AudioKit.ClipRecordingCompletion) throws
}
extension AKClipRecorder : AudioKit.AKTiming {
  @objc dynamic public var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic public func stop()
  @objc dynamic public func setPosition(_ position: Swift.Double)
  @objc dynamic public func position(at audioTime: AVFoundation.AVAudioTime?) -> Swift.Double
  @objc dynamic public func audioTime(at position: Swift.Double) -> AVFoundation.AVAudioTime?
}
public enum ClipRecordingError : Swift.Error, Foundation.LocalizedError {
  case timingError
  case invalidParameters
  case clipIsEmpty
  case formatError
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: AudioKit.ClipRecordingError, b: AudioKit.ClipRecordingError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension AKManager {
  @objc public static var tester: AudioKit.AKTester?
  @objc public static func test(node: AudioKit.AKNode, duration: Swift.Double, afterStart: () -> Swift.Void = {}) throws
  @objc public static func auditionTest(node: AudioKit.AKNode, duration: Swift.Double) throws
}
@_hasMissingDesignatedInitializers open class AKAUPresetBuilder {
  public static func createAUPreset(dict: [Foundation.NSMutableDictionary], path: Swift.String, instrumentName: Swift.String, attack: Swift.Double? = 0, release: Swift.Double? = 0)
  public static func generateDictionary(rootNote: Swift.Int, filename: Swift.String, startNote: Swift.Int, endNote: Swift.Int) -> Foundation.NSMutableDictionary
  public static func buildInstrument(name: Swift.String = "Coded Instrument Name", connections: Swift.String = "", envelopes: Swift.String = "", filter: Swift.String = "", lfos: Swift.String = "", zones: Swift.String = "***ZONES***\n", filerefs: Swift.String = "***FILEREFS***\n", layers: Swift.String = "") -> Swift.String
  @objc deinit
}
public enum SampleTriggerMode : Swift.String {
  case Hold
  case Trigger
  case Loop
  case Repeat
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension AKTuningTable {
  public func scalaFile(_ filePath: Swift.String) -> Swift.Int?
  open func frequencies(fromScalaString rawStr: Swift.String?) -> [AudioKit.AKTuningTable.Frequency]?
}
public enum AKMIDIMetaEventType : AudioKit.MIDIByte {
  case sequenceNumber
  case textEvent
  case copyright
  case trackName
  case instrumentName
  case lyric
  case marker
  case cuePoint
  case channelPrefix
  case midiPort
  case endOfTrack
  case setTempo
  case smtpeOffset
  case timeSignature
  case keySignature
  case sequencerSpecificMetaEvent
  public var description: Swift.String {
    get
  }
  public typealias RawValue = AudioKit.MIDIByte
  public init?(rawValue: AudioKit.MIDIByte)
  public var rawValue: AudioKit.MIDIByte {
    get
  }
}
public struct AKMIDIMetaEvent : AudioKit.AKMIDIMessage {
  public init?(data: [AudioKit.MIDIByte])
  public var data: [AudioKit.MIDIByte]
  public var type: AudioKit.AKMIDIMetaEventType
  public var length: Swift.Int
  public var description: Swift.String {
    get
  }
  public var name: Swift.String? {
    get
  }
}
public struct AKMIDIFileChunkEvent {
}
extension AKOperation {
  public static func randomVertexPulse(minimum: AudioKit.AKParameter = 0, maximum: AudioKit.AKParameter = 1, updateFrequency: AudioKit.AKParameter = 3) -> AudioKit.AKOperation
}
@objc open class AKLowShelfParametricEqualizerFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKLowShelfParametricEqualizerFilterAudioUnit
  public var internalAU: AudioKit.AKLowShelfParametricEqualizerFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cornerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var gainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var qRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCornerFrequency: AudioToolbox.AUValue
  public static var defaultGain: AudioToolbox.AUValue
  public static var defaultQ: AudioToolbox.AUValue
  final public let cornerFrequency: AudioKit.AKNodeParameter
  final public let gain: AudioKit.AKNodeParameter
  final public let q: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cornerFrequency: AudioToolbox.AUValue = defaultCornerFrequency, gain: AudioToolbox.AUValue = defaultGain, q: AudioToolbox.AUValue = defaultQ)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKLowShelfParametricEqualizerFilter
}
extension AKOperation {
  public static func triangleWave(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func bitCrush(bitDepth: AudioKit.AKParameter = 8, sampleRate: AudioKit.AKParameter = 10_000) -> AudioKit.AKOperation
}
@objc open class AKCombFilterReverb : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKCombFilterReverbAudioUnit
  public var internalAU: AudioKit.AKCombFilterReverb.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var reverbDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultReverbDuration: AudioToolbox.AUValue
  public static var defaultLoopDuration: AudioToolbox.AUValue
  final public let reverbDuration: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, reverbDuration: AudioToolbox.AUValue = defaultReverbDuration, loopDuration: AudioToolbox.AUValue = defaultLoopDuration)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKCombFilterReverb
}
@objc open class AKMorphingOscillatorBank : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKMorphingOscillatorBankAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKMorphingOscillatorBank.AKAudioUnitType? {
    get
  }
  @objc open var waveformArray: [AudioKit.AKTable] {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var index: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveformArray: [AudioKit.AKTable] = [AKTable(.triangle), AKTable(.square), AKTable(.sine), AKTable(.sawtooth)], index: AudioToolbox.AUValue = 0, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0)
  open func reset()
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKMorphingOscillatorBank
}
extension AKOperation {
  public static func sawtooth(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5, phase: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
  public static func reverseSawtooth(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5, phase: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
@objc open class AKPWMOscillatorBank : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKPWMOscillatorBankAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKPWMOscillatorBank.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pulseWidth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(pulseWidth: AudioToolbox.AUValue = 0.5, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPWMOscillatorBank
}
extension AKOperation {
  public static func triangle(frequency: AudioKit.AKParameter = 440, amplitude: AudioKit.AKParameter = 0.5, phase: AudioKit.AKParameter = 0) -> AudioKit.AKOperation
}
@objc open class AKHighShelfFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var cutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var gain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, cutOffFrequency: AudioToolbox.AUValue = 10_000, gain: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKHighShelfFilter
}
public protocol AKMIDIBeatObserver {
  func preparePlay(continue: Swift.Bool)
  func startFirstBeat(continue: Swift.Bool)
  func stopSRT()
  func receivedBeatEvent(beat: Swift.UInt64)
  func receivedQuantum(time: CoreMIDI.MIDITimeStamp, quarterNote: Swift.UInt8, beat: Swift.UInt64, quantum: Swift.UInt64)
  func receivedQuarterNoteBeat(quarterNote: Swift.UInt8)
}
extension AKMIDIBeatObserver {
  public func preparePlay(continue: Swift.Bool)
  public func startFirstBeat(continue: Swift.Bool)
  public func stopSRT()
  public func receivedBeatEvent(beat: Swift.UInt64)
  public func receivedQuantum(time: CoreMIDI.MIDITimeStamp, quarterNote: Swift.UInt8, beat: Swift.UInt64, quantum: Swift.UInt64)
  public func receivedQuarterNoteBeat(quarterNote: Swift.UInt8)
  public func isEqualTo(_ listener: AudioKit.AKMIDIBeatObserver) -> Swift.Bool
}
@objc open class AKHighShelfParametricEqualizerFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKHighShelfParametricEqualizerFilterAudioUnit
  public var internalAU: AudioKit.AKHighShelfParametricEqualizerFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var gainRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var qRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultGain: AudioToolbox.AUValue
  public static var defaultQ: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let gain: AudioKit.AKNodeParameter
  final public let q: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, gain: AudioToolbox.AUValue = defaultGain, q: AudioToolbox.AUValue = defaultQ)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKHighShelfParametricEqualizerFilter
}
@objc open class AKAmplitudeEnvelope : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKAmplitudeEnvelopeAudioUnit
  public var internalAU: AudioKit.AKAmplitudeEnvelope.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var attackDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var decayDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var sustainLevelRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var releaseDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultAttackDuration: AudioToolbox.AUValue
  public static var defaultDecayDuration: AudioToolbox.AUValue
  public static var defaultSustainLevel: AudioToolbox.AUValue
  public static var defaultReleaseDuration: AudioToolbox.AUValue
  final public let attackDuration: AudioKit.AKNodeParameter
  final public let decayDuration: AudioKit.AKNodeParameter
  final public let sustainLevel: AudioKit.AKNodeParameter
  final public let releaseDuration: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, attackDuration: AudioToolbox.AUValue = defaultAttackDuration, decayDuration: AudioToolbox.AUValue = defaultDecayDuration, sustainLevel: AudioToolbox.AUValue = defaultSustainLevel, releaseDuration: AudioToolbox.AUValue = defaultReleaseDuration)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKAmplitudeEnvelope
}
@objc open class AKMIDINode : AudioKit.AKNode, AudioKit.AKMIDIListener {
  open var midiIn: CoreMIDI.MIDIEndpointRef
  open var name: Swift.String
  @objc public init(node: AudioKit.AKPolyphonicNode, midiOutputName: Swift.String? = nil)
  open func enableMIDI(_ midiClient: CoreMIDI.MIDIClientRef = AKManager.midi.client, name: Swift.String = "Unnamed")
  open func receivedMIDINoteOn(_ noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc @_inheritsConvenienceInitializers public class AKPeakingParametricEqualizerFilterAudioUnit : AudioKit.AKAudioUnitBase {
  override public func createDSP() -> AudioKit.AKDSPRef
  @objc override dynamic public init(componentDescription: AudioToolbox.AudioComponentDescription, options: AudioToolbox.AudioComponentInstantiationOptions = []) throws
  @objc deinit
}
@objc open class AKFormantFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKFormantFilterAudioUnit
  public var internalAU: AudioKit.AKFormantFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var centerFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var attackDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var decayDurationRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCenterFrequency: AudioToolbox.AUValue
  public static var defaultAttackDuration: AudioToolbox.AUValue
  public static var defaultDecayDuration: AudioToolbox.AUValue
  final public let centerFrequency: AudioKit.AKNodeParameter
  final public let attackDuration: AudioKit.AKNodeParameter
  final public let decayDuration: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, centerFrequency: AudioToolbox.AUValue = defaultCenterFrequency, attackDuration: AudioToolbox.AUValue = defaultAttackDuration, decayDuration: AudioToolbox.AUValue = defaultDecayDuration)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKFormantFilter
}
@objc open class AKClipper : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKClipperAudioUnit
  public var internalAU: AudioKit.AKClipper.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var limitRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultLimit: AudioToolbox.AUValue
  final public let limit: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, limit: AudioToolbox.AUValue = defaultLimit)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKClipper
}
@objc open class AKStereoDelay : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKStereoDelayAudioUnit
  public var internalAU: AudioKit.AKStereoDelay.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation?
  public static var timeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var feedbackRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var dryWetMixRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultTime: AudioToolbox.AUValue
  public static var defaultFeedback: AudioToolbox.AUValue
  public static var defaultDryWetMix: AudioToolbox.AUValue
  final public let time: AudioKit.AKNodeParameter
  final public let feedback: AudioKit.AKNodeParameter
  final public let dryWetMix: AudioKit.AKNodeParameter
  final public let pingPong: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, maximumDelayTime: AudioToolbox.AUValue = AKStereoDelay.timeRange.upperBound, time: AudioToolbox.AUValue = defaultTime, feedback: AudioToolbox.AUValue = defaultFeedback, dryWetMix: AudioToolbox.AUValue = defaultDryWetMix, pingPong: Swift.Bool = false)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKStereoDelay
}
open class AKMIDI {
  open var client: CoreMIDI.MIDIClientRef
  public var inputPorts: [CoreMIDI.MIDIUniqueID : CoreMIDI.MIDIPortRef]
  open var virtualInput: CoreMIDI.MIDIPortRef
  public var outputPort: CoreMIDI.MIDIPortRef
  open var virtualOutput: CoreMIDI.MIDIPortRef
  open var endpoints: [CoreMIDI.MIDIUniqueID : CoreMIDI.MIDIEndpointRef]
  public var listeners: [AudioKit.AKMIDIListener]
  public var transformers: [AudioKit.AKMIDITransformer]
  @objc public init()
  @objc deinit
}
public func min(_ x: AudioKit.AKComputedParameter, _ y: AudioKit.AKComputedParameter) -> AudioKit.AKOperation
public func min(_ operation: AudioKit.AKComputedParameter, _ parameter: AudioKit.AKParameter) -> AudioKit.AKOperation
public func min(_ parameter: AudioKit.AKParameter, _ operation: AudioKit.AKComputedParameter) -> AudioKit.AKOperation
@objc open class AKPhaseDistortionOscillator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPhaseDistortionOscillatorAudioUnit
  public var internalAU: AudioKit.AKPhaseDistortionOscillator.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var phaseDistortionRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningOffsetRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var detuningMultiplierRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultAmplitude: AudioToolbox.AUValue
  public static var defaultPhaseDistortion: AudioToolbox.AUValue
  public static var defaultDetuningOffset: AudioToolbox.AUValue
  public static var defaultDetuningMultiplier: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let amplitude: AudioKit.AKNodeParameter
  final public let phaseDistortion: AudioKit.AKNodeParameter
  final public let detuningOffset: AudioKit.AKNodeParameter
  final public let detuningMultiplier: AudioKit.AKNodeParameter
  public init(waveform: AudioKit.AKTable = AKTable(.sine), frequency: AudioToolbox.AUValue = defaultFrequency, amplitude: AudioToolbox.AUValue = defaultAmplitude, phaseDistortion: AudioToolbox.AUValue = defaultPhaseDistortion, detuningOffset: AudioToolbox.AUValue = defaultDetuningOffset, detuningMultiplier: AudioToolbox.AUValue = defaultDetuningMultiplier)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPhaseDistortionOscillator
}
@objc open class AKAutoPanner : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKAutoPannerAudioUnit
  public var internalAU: AudioKit.AKAutoPanner.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  final public let frequency: AudioKit.AKNodeParameter
  final public let depth: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = 10, depth: AudioToolbox.AUValue = 1.0, waveform: AudioKit.AKTable = AKTable(.positiveSine))
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKAutoPanner
}
@objc open class AKRingModulator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var frequency1: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var frequency2: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var balance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var mix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, frequency1: AudioToolbox.AUValue = 100, frequency2: AudioToolbox.AUValue = 100, balance: AudioToolbox.AUValue = 0.5, mix: AudioToolbox.AUValue = 1)
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKRingModulator
}
@objc open class AKDynamicsProcessor : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKInput {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  @objc dynamic open var threshold: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var headRoom: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var expansionRatio: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var expansionThreshold: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var masterGain: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var compressionAmount: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var inputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var outputAmplitude: AudioToolbox.AUValue {
    @objc get
  }
  @objc dynamic open var dryWetMix: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input: AudioKit.AKNode? = nil, threshold: AudioToolbox.AUValue = -20, headRoom: AudioToolbox.AUValue = 5, expansionRatio: AudioToolbox.AUValue = 2, expansionThreshold: AudioToolbox.AUValue = 2, attackDuration: AudioToolbox.AUValue = 0.001, releaseDuration: AudioToolbox.AUValue = 0.05, masterGain: AudioToolbox.AUValue = 0, compressionAmount: AudioToolbox.AUValue = 0, inputAmplitude: AudioToolbox.AUValue = 0, outputAmplitude: AudioToolbox.AUValue = 0)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  @objc open func start()
  @objc open func stop()
  override open func detach()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDynamicsProcessor
}
extension AKComputedParameter {
  public func reverberateWithFlatFrequencyResponse(reverbDuration: AudioKit.AKParameter = 0.5, loopDuration: Swift.Double = 0.1) -> AudioKit.AKOperation
}
@objc open class AKLowPassButterworthFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKLowPassButterworthFilterAudioUnit
  public var internalAU: AudioKit.AKLowPassButterworthFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var cutoffFrequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultCutoffFrequency: AudioToolbox.AUValue
  final public let cutoffFrequency: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, cutoffFrequency: AudioToolbox.AUValue = defaultCutoffFrequency)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKLowPassButterworthFilter
}
extension AKComputedParameter {
  public func autoWah(wah: AudioKit.AKParameter = 0, amplitude: AudioKit.AKParameter = 0.1) -> AudioKit.AKOperation
}
extension AKComputedParameter {
  public func lowPassFilter(halfPowerPoint: AudioKit.AKParameter = 1_000) -> AudioKit.AKOperation
}
@objc open class AKPhaseDistortionOscillatorFilterSynth : AudioKit.AKPolyphonicNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKPhaseDistortionOscillatorFilterSynthAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKPhaseDistortionOscillatorFilterSynth.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var phaseDistortion: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var attackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var decayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var sustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var releaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var pitchBend: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoDepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var vibratoRate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterCutoffFrequency: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterResonance: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterAttackDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterDecayDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterSustainLevel: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterReleaseDuration: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterEnvelopeStrength: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFODepth: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var filterLFORate: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc public init(waveform: AudioKit.AKTable = AKTable(.sine), phaseDistortion: AudioToolbox.AUValue = 0.0, attackDuration: AudioToolbox.AUValue = 0.1, decayDuration: AudioToolbox.AUValue = 0.1, sustainLevel: AudioToolbox.AUValue = 1.0, releaseDuration: AudioToolbox.AUValue = 0.1, pitchBend: AudioToolbox.AUValue = 0, vibratoDepth: AudioToolbox.AUValue = 0, vibratoRate: AudioToolbox.AUValue = 0, filterCutoffFrequency: AudioToolbox.AUValue = 22_050.0, filterResonance: AudioToolbox.AUValue = 0.0, filterAttackDuration: AudioToolbox.AUValue = 0.1, filterDecayDuration: AudioToolbox.AUValue = 0.1, filterSustainLevel: AudioToolbox.AUValue = 1.0, filterReleaseDuration: AudioToolbox.AUValue = 1.0, filterEnvelopeStrength: AudioToolbox.AUValue = 0.0, filterLFODepth: AudioToolbox.AUValue = 0.0, filterLFORate: AudioToolbox.AUValue = 0.0)
  @objc override open func play(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, frequency: AudioToolbox.AUValue, channel: AudioKit.MIDIChannel = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPhaseDistortionOscillatorFilterSynth
}
open class AKParameterAutomation {
  public init(_ avAudioUnit: AVFoundation.AVAudioUnit)
  @objc deinit
  public func startPlayback(offset: Swift.Double = 0, rate: Swift.Double = 1)
  public func startPlayback(at absoluteTime: AVFoundation.AVAudioTime, offset: Swift.Double = 0, rate: Swift.Double = 1)
  public func stopPlayback()
  public func setRecordingEnabled(_ enabled: Swift.Bool, for parameter: Swift.String)
  public func isRecordingEnabled(for parameter: Swift.String) -> Swift.Bool
  public func getPoints(of parameter: Swift.String) -> [AudioKit.AKParameterAutomationPoint]
  public func add(point: AudioKit.AKParameterAutomationPoint, to parameter: Swift.String)
  public func add(points: [AudioKit.AKParameterAutomationPoint], to parameter: Swift.String)
  public func set(points: [AudioKit.AKParameterAutomationPoint], of parameter: Swift.String)
  public func clear(range: Swift.ClosedRange<Swift.Double>, of parameter: Swift.String)
  public func clearAllPoints(of parameter: Swift.String)
}
extension AKParameterAutomationPoint {
  public init(targetValue: AudioToolbox.AUValue, startTime: Swift.Double, rampDuration: Swift.Double)
}
@objc open class AKPinkNoise : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKPinkNoiseAudioUnit
  public var internalAU: AudioKit.AKPinkNoise.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var amplitudeRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultAmplitude: AudioToolbox.AUValue
  final public let amplitude: AudioKit.AKNodeParameter
  public init(amplitude: AudioToolbox.AUValue = defaultAmplitude)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKPinkNoise
}
@objc open class AKDryWetMixer : AudioKit.AKNode, AudioKit.AKInput {
  @objc dynamic open var balance: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var isStarted: Swift.Bool
  @objc public init(_ input1: AudioKit.AKNode? = nil, _ input2: AudioKit.AKNode? = nil, balance: Swift.Double = 0.5)
  @objc public convenience init(dry: AudioKit.AKNode, wet: AudioKit.AKNode, balance: Swift.Double = 0.5)
  public var inputNode: AVFoundation.AVAudioNode {
    get
  }
  override open func detach()
  @objc open var dryInput: AVFoundation.AVAudioConnectionPoint {
    @objc get
  }
  @objc open var wetInput: AVFoundation.AVAudioConnectionPoint {
    @objc get
  }
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
}
@objc @_inheritsConvenienceInitializers open class AKSettings : ObjectiveC.NSObject {
  @objc public enum BufferLength : Swift.Int {
    case shortest = 5
    case veryShort = 6
    case short = 7
    case medium = 8
    case long = 9
    case veryLong = 10
    case huge = 11
    case longest = 12
    public var samplesCount: AVFoundation.AVAudioFrameCount {
      get
    }
    public var duration: Swift.Double {
      get
    }
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public enum RampType : Swift.Int {
    case linear = 0
    case exponential = 1
    case logarithmic = 2
    case sCurve = 3
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public static var defaultAudioFormat: AVFoundation.AVAudioFormat
  @objc public static var sampleRate: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc public static var channelCount: Swift.UInt32 {
    @objc get
    @objc set(newValue)
  }
  @objc public static var audioInputEnabled: Swift.Bool
  @objc public static var rampDuration: Swift.Double
  @objc public static var notificationsEnabled: Swift.Bool
  @objc public static var bufferLength: AudioKit.AKSettings.BufferLength
  @objc public static var recordingBufferLength: AudioKit.AKSettings.BufferLength
  @objc public static var fixTruncatedRecordings: Swift.Bool
  @objc public static var enableLogging: Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
extension AKSettings {
  @objc public static var audioFormat: AVFoundation.AVAudioFormat
  @objc public static var ioBufferDuration: Swift.Double {
    @objc get
    @objc set(newValue)
  }
}
@objc open class AKBooster : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKBoosterAudioUnit
  public var internalAU: AudioKit.AKBooster.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation?
  open var gain: AudioToolbox.AUValue {
    get
    set(value)
  }
  final public let leftGain: AudioKit.AKNodeParameter
  final public let rightGain: AudioKit.AKNodeParameter
  open var dB: AudioToolbox.AUValue {
    get
    set(newValue)
  }
  @objc public init(_ input: AudioKit.AKNode? = nil, gain: AudioToolbox.AUValue = 1)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKBooster
}
@objc open class AKMIDICallbackInstrument : AudioKit.AKMIDIInstrument {
  open var callback: AudioKit.AKMIDICallback?
  public init(midiInputName: Swift.String = "AudioKit Callback Instrument", callback: AudioKit.AKMIDICallback? = nil)
  @objc override open func start(noteNumber: AudioKit.MIDINoteNumber, velocity: AudioKit.MIDIVelocity, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc override open func stop(noteNumber: AudioKit.MIDINoteNumber, channel: AudioKit.MIDIChannel, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIController(_ controller: AudioKit.MIDIByte, value: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIAftertouch(noteNumber: AudioKit.MIDINoteNumber, pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIAftertouch(_ pressure: AudioKit.MIDIByte, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  override open func receivedMIDIPitchWheel(_ pitchWheelValue: AudioKit.MIDIWord, channel: AudioKit.MIDIChannel, portID: CoreMIDI.MIDIUniqueID? = nil, offset: CoreMIDI.MIDITimeStamp = 0)
  @objc deinit
  override public init(midiInputName: Swift.String? = super)
}
@objc open class AKOperationGenerator : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKOperationGeneratorAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKOperationGenerator.AKAudioUnitType? {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  @objc dynamic open var sporth: Swift.String {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var parameters: [Swift.Double] {
    @objc get
    @objc set(newValue)
  }
  public convenience init(operation: ([AudioKit.AKOperation]) -> AudioKit.AKComputedParameter)
  public convenience init(channelCount: Swift.Int, operations: ([AudioKit.AKOperation]) -> [AudioKit.AKOperation])
  @objc public init(sporth: Swift.String = "", customUgens: [AudioKit.AKCustomUgen] = [])
  open func trigger(_ triggerNumber: Swift.Int = 0)
  @objc open func start()
  @objc open func stop()
  open func restart()
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKOperationGenerator
}
extension AKComputedParameter {
  public func modalResonanceFilter(frequency: AudioKit.AKParameter = 500.0, qualityFactor: AudioKit.AKParameter = 50.0) -> AudioKit.AKOperation
}
@objc open class AKModalResonanceFilter : AudioKit.AKNode, AudioKit.AKToggleable, AudioKit.AKComponent, AudioKit.AKInput, AudioKit.AKAutomatable {
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public typealias AKAudioUnitType = AudioKit.AKModalResonanceFilterAudioUnit
  public var internalAU: AudioKit.AKModalResonanceFilter.AKAudioUnitType? {
    get
  }
  public var parameterAutomation: AudioKit.AKParameterAutomation? {
    get
  }
  public static var frequencyRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var qualityFactorRange: Swift.ClosedRange<AudioToolbox.AUValue>
  public static var defaultFrequency: AudioToolbox.AUValue
  public static var defaultQualityFactor: AudioToolbox.AUValue
  final public let frequency: AudioKit.AKNodeParameter
  final public let qualityFactor: AudioKit.AKNodeParameter
  public init(_ input: AudioKit.AKNode? = nil, frequency: AudioToolbox.AUValue = defaultFrequency, qualityFactor: AudioToolbox.AUValue = defaultQualityFactor)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKModalResonanceFilter
}
@objc open class AKDiskStreamer : AudioKit.AKNode, AudioKit.AKComponent {
  public typealias AKAudioUnitType = AudioKit.AKDiskStreamerAudioUnit
  public static var ComponentDescription: AudioToolbox.AudioComponentDescription
  public var internalAU: AudioKit.AKDiskStreamer.AKAudioUnitType? {
    get
  }
  @objc dynamic open var rampDuration: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var rate: AudioToolbox.AUValue {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic open var volume: AudioToolbox.AUValue {
    @objc get
    @objc set(value)
  }
  @objc dynamic open var loopEnabled: Swift.Bool {
    @objc get
    @objc set(value)
  }
  open var size: AudioKit.Sample {
    get
  }
  open var originalSampleRate: Swift.Double? {
    get
  }
  open var normalizedPosition: AudioToolbox.AUValue {
    get
  }
  open var position: AudioToolbox.AUValue {
    get
  }
  @objc dynamic open var isStarted: Swift.Bool {
    @objc get
  }
  open var loadCompletionHandler: () -> Swift.Void {
    get
    set(value)
  }
  open var completionHandler: () -> Swift.Void {
    get
    set(value)
  }
  open var loadedFile: AudioKit.AKAudioFile?
  @objc public init(volume: AudioToolbox.AUValue = 1, completionHandler: @escaping AudioKit.AKCCallback = {}, loadCompletionHandler: @escaping AudioKit.AKCCallback = {})
  @objc open func start()
  @objc open func stop()
  open func play()
  open func load(file: AudioKit.AKAudioFile)
  open func rewind()
  open func seek(to sample: AudioToolbox.AUValue)
  @objc deinit
  override public init(avAudioUnit: AVFoundation.AVAudioUnit, attach: Swift.Bool = super)
  override public init(avAudioNode: AVFoundation.AVAudioNode, attach: Swift.Bool = super)
  public typealias _Self = AudioKit.AKDiskStreamer
}
extension AudioKit.AKCompressor : AudioKit.AUComponent {}
extension AudioKit.AKDistortion : AudioKit.AUComponent {}
extension AudioKit.AKHighPassFilter : AudioKit.AUComponent {}
extension AudioKit.AKDecimator : AudioKit.AUComponent {}
extension AudioKit.AKExpander : AudioKit.AUComponent {}
extension AudioKit.AKPeakLimiter : AudioKit.AUComponent {}
extension AudioKit.AKLowShelfFilter : AudioKit.AUComponent {}
extension AudioKit.AKLowPassFilter : AudioKit.AUComponent {}
extension AudioKit.AKHighShelfFilter : AudioKit.AUComponent {}
extension AudioKit.AKRingModulator : AudioKit.AUComponent {}
extension AudioKit.AKDynamicsProcessor : AudioKit.AUComponent {}
